{
    "docs": [
        {
            "location": "/", 
            "text": "Elcodi Documentation\n\n\nThis documentation is rendered online at \n\nhttp://elcodi.io/docs\n\n\n\n\nQuick Start\n\n\nThe Book\n\n\nThe Cookbook\n\n\nThe Components\n\n\nThe Bundles\n\n\nThe Reference", 
            "title": "Home"
        }, 
        {
            "location": "/#elcodi-documentation", 
            "text": "This documentation is rendered online at  http://elcodi.io/docs   Quick Start  The Book  The Cookbook  The Components  The Bundles  The Reference", 
            "title": "Elcodi Documentation"
        }, 
        {
            "location": "/quick-start/", 
            "text": "Bamboo e-commerce\n\n\n\n\n\n\nWarning. This project is not tagged as stable yet. During this Beta stage, we\naim to find and resolve all bugs, empower testing layer and build even a \nbetter and bigger project documentation.\n\n\n\n\nWelcome to Bamboo e-commerce - a fully-functional e-commerce application built\nusing \nElcodi\n components on top of the \nSymfony\n framework.\n\n\nYes, you got it right! Bamboo uses the Symfony framework but our components are\nframework agnostic, that is, they only depend on the Symfony components as \nopposed to the whole framework or any of its distributions.\n\n\nWhy should I use Bamboo? That's simple, to sell your products. We provide you \nwith an interface to sell your products and manage your store. You only have to \nfocus on offering a good product, we take care of the rest.\n\n\nRequirements\n\n\nWe're trying to build this project with a light default dependencies.\n\n\nPHP\n\n\nTo use Bamboo and Elcodi you need a PHP version not less than \n5.4\n\n\nFor more info just visit their\n\ninstallation page\n\n\nPHP GD\n\n\nImages are a really important part of an store. Bamboo uses PHP GD to\nresize and optimize all product images\n\n\nFor more info just visit their\n\ninstallation page\n\n\n\n\nThis PHP extension is used to being already installed when you add PHP in your\ndistribution\n\n\n\n\nAfter that, you will be able to change the adapter and use other \nimplementations.\n\n\nMySQL\n\n\nAnd, where do you save your data? By default we use MySQL, remember to install\nit as well as its extension for PHP\n\n\nFor more info just visit their\n\ninstallation page\n\n\nComposer\n\n\nComposer\n is required to manage dependencies.\n\n\nif you have not yet installed Composer, download it following the instructions\non \nhttp://getcomposer.org/\n or just run the following\ncommand:\n\n\n$ curl -s http://getcomposer.org/installer | php\n\n\n\n\nRedis\n\n\nBamboo uses redis to make the app lighter and to minimize the response time.\n\n\nFor more info just visit their\n\ninstallation page\n\n\nIn order to use the last Redis features, like the \nHyperLogLog\n commands, be\nsure your Redis version is at least \nv2.8.9\n.\n\n\nInstallation\n\n\nIf you're used to working with LAMP environment, then you will have Bamboo \nrunning in your computer in less than 5 minutes.\n\n\n1. Install the project\n\n\nAfter installing composer you can create your new bamboo project. Feel free to\nuse any version, but we're still creating new features, fixing some issues and\nerrors, and building our first release, so feel free to use them\n\n\n$ php composer.phar create-project elcodi/bamboo bamboo -sdev\n\n\n\n\n\n\nThe installation process will ask you for some parameters like the database\ndriver, username, password, database name, etc\n\n\n\n\nEnter your directory to start the configuration step\n\n\n$ cd bamboo/\n\n\n\n\n2. Init your database\n\n\nNow we should create the database and all the application schema. Symfony\nprovides you an easy way for doing that.\n\n\n$ php app/console doctrine:database:create\n$ php app/console doctrine:schema:create\n\n\n\n\nWe also load some fixtures to show on our store. This fixtures will set your\nstore in a testing mode, with some categories, some manufacturers and a bunch of\nt-shirts. Only for testing purposes :)\n\n\n$ php app/console doctrine:fixtures:load \\\n      --fixtures=\nsrc/Elcodi/Fixtures\n \\\n      --fixtures=\nsrc/Elcodi/Plugin\n \\\n      --no-interaction\n\n\n\n\nThese fixtures will not install you any location data, but don't worry, we \nprovide you several ways for your location population.\n\n\nWe provide you some files with some countries dumped. You will find these files\ninside \nelcodi/geo-bundle\n package, inside the \nDataFixtures/ORM/Dumps\n folder.\nBecause location tables are not using foreign keys, you can play with them as\nmuch as you need.\n\n\n$ mysql -uroot -proot bamboo \n vendor/elcodi/elcodi/src/Elcodi/Bundle/GeoBundle/DataFixtures/ORM/Dumps/spain.sql\n\n\n\n\nYou can also add the geo information for any country. Just find the two letters\n\nISO code\n for the\ncountry you want to load and launch the following command changing ES with your\ncode.\n\n\n$ php app/console elcodi:locations:populate ES\n\n\n\n\nThis could take several minutes per country, be patient and provide PHP as much\nmemory as possible.\n\n\n3. Load the plugins\n\n\nBamboo offers a bunch of plugins to customize your store. In the ecosystem of\nBamboo, a Plugin is just a Bundle, so first of all, check that all the plugins\nyou want to use are actually instantiated in you \nAppKernel\n class, under \napp/\n\nfolder.\n\n\nTo install load these plugins, use this command\n\n\n$ php app/console elcodi:plugins:load\n\n\n\n\nThe default template is a plugin as well, so you will install it as well with\nthis command.\n\n\n4. Run the server\n\n\nFinally our store is ready to run :)\n\n\n$ php app/console server:run\n\n\n\n\nYou can also \nconfigure a Web server\n like Apache or Nginx to run the app like\nall the Symfony apps.\n\n\n5. Visit your store\n\n\nYehaaa! You're done! You're about to see what Elcodi can do for you. A complete\nstore interface for your customers and some nice features for administrating it.\n\n\nYou can start using these credentials we've already created for you. For the\nadmin panel use. Remember to remove them properly when your store is on \nproduction.\n\n\nAdmin username: admin@admin.com\nAdmin password: 1234\n\n\n\n\nAnd for the store, use this Customer credentials.\n\n\nCustomer username: customer@customer.com\nCustomer password: 1234\n\n\n\n\n6. Play!\n\n\nYou can now play with the bamboo :)\nDon't forget to \ncreate an issue\n on\n\nBamboo\n or\n\nElcodi\n if you found any bug.\nAny collaboration is welcome! We look forward to hearing from you!\n\n\nTests\n\n\nYes, we are doing some tests, and this will be \nin cresciendo\n. You can ensure\nyourself that all the cases we've been working on are actually green. We are\nusing Behat and PHPUnit, so you only need to execute all suites by using this\npiece of code.\n\n\n$ php bin/behat\n$ php bin/phpunit -c app\n$ php app/console visithor:go --format=pretty --env=test\n\n\n\n\nIssues\n\n\nYou can report any issue on \nBamboo\n or\n\nElcodi\n\n\nNeed help\n\n\nIf you need any help with the installation or understanding elcodi or bamboo you\ncan contact us on \ngitter\n.\nWe will be glad to help you, just ask for help.", 
            "title": "Quick start"
        }, 
        {
            "location": "/quick-start/#bamboo-e-commerce", 
            "text": "Warning. This project is not tagged as stable yet. During this Beta stage, we\naim to find and resolve all bugs, empower testing layer and build even a \nbetter and bigger project documentation.   Welcome to Bamboo e-commerce - a fully-functional e-commerce application built\nusing  Elcodi  components on top of the  Symfony  framework.  Yes, you got it right! Bamboo uses the Symfony framework but our components are\nframework agnostic, that is, they only depend on the Symfony components as \nopposed to the whole framework or any of its distributions.  Why should I use Bamboo? That's simple, to sell your products. We provide you \nwith an interface to sell your products and manage your store. You only have to \nfocus on offering a good product, we take care of the rest.", 
            "title": "Bamboo e-commerce"
        }, 
        {
            "location": "/quick-start/#requirements", 
            "text": "We're trying to build this project with a light default dependencies.  PHP  To use Bamboo and Elcodi you need a PHP version not less than  5.4  For more info just visit their installation page  PHP GD  Images are a really important part of an store. Bamboo uses PHP GD to\nresize and optimize all product images  For more info just visit their installation page   This PHP extension is used to being already installed when you add PHP in your\ndistribution   After that, you will be able to change the adapter and use other \nimplementations.  MySQL  And, where do you save your data? By default we use MySQL, remember to install\nit as well as its extension for PHP  For more info just visit their installation page  Composer  Composer  is required to manage dependencies.  if you have not yet installed Composer, download it following the instructions\non  http://getcomposer.org/  or just run the following\ncommand:  $ curl -s http://getcomposer.org/installer | php  Redis  Bamboo uses redis to make the app lighter and to minimize the response time.  For more info just visit their installation page  In order to use the last Redis features, like the  HyperLogLog  commands, be\nsure your Redis version is at least  v2.8.9 .", 
            "title": "Requirements"
        }, 
        {
            "location": "/quick-start/#installation", 
            "text": "If you're used to working with LAMP environment, then you will have Bamboo \nrunning in your computer in less than 5 minutes.  1. Install the project  After installing composer you can create your new bamboo project. Feel free to\nuse any version, but we're still creating new features, fixing some issues and\nerrors, and building our first release, so feel free to use them  $ php composer.phar create-project elcodi/bamboo bamboo -sdev   The installation process will ask you for some parameters like the database\ndriver, username, password, database name, etc   Enter your directory to start the configuration step  $ cd bamboo/  2. Init your database  Now we should create the database and all the application schema. Symfony\nprovides you an easy way for doing that.  $ php app/console doctrine:database:create\n$ php app/console doctrine:schema:create  We also load some fixtures to show on our store. This fixtures will set your\nstore in a testing mode, with some categories, some manufacturers and a bunch of\nt-shirts. Only for testing purposes :)  $ php app/console doctrine:fixtures:load \\\n      --fixtures= src/Elcodi/Fixtures  \\\n      --fixtures= src/Elcodi/Plugin  \\\n      --no-interaction  These fixtures will not install you any location data, but don't worry, we \nprovide you several ways for your location population.  We provide you some files with some countries dumped. You will find these files\ninside  elcodi/geo-bundle  package, inside the  DataFixtures/ORM/Dumps  folder.\nBecause location tables are not using foreign keys, you can play with them as\nmuch as you need.  $ mysql -uroot -proot bamboo   vendor/elcodi/elcodi/src/Elcodi/Bundle/GeoBundle/DataFixtures/ORM/Dumps/spain.sql  You can also add the geo information for any country. Just find the two letters ISO code  for the\ncountry you want to load and launch the following command changing ES with your\ncode.  $ php app/console elcodi:locations:populate ES  This could take several minutes per country, be patient and provide PHP as much\nmemory as possible.  3. Load the plugins  Bamboo offers a bunch of plugins to customize your store. In the ecosystem of\nBamboo, a Plugin is just a Bundle, so first of all, check that all the plugins\nyou want to use are actually instantiated in you  AppKernel  class, under  app/ \nfolder.  To install load these plugins, use this command  $ php app/console elcodi:plugins:load  The default template is a plugin as well, so you will install it as well with\nthis command.  4. Run the server  Finally our store is ready to run :)  $ php app/console server:run  You can also  configure a Web server  like Apache or Nginx to run the app like\nall the Symfony apps.  5. Visit your store  Yehaaa! You're done! You're about to see what Elcodi can do for you. A complete\nstore interface for your customers and some nice features for administrating it.  You can start using these credentials we've already created for you. For the\nadmin panel use. Remember to remove them properly when your store is on \nproduction.  Admin username: admin@admin.com\nAdmin password: 1234  And for the store, use this Customer credentials.  Customer username: customer@customer.com\nCustomer password: 1234  6. Play!  You can now play with the bamboo :)\nDon't forget to  create an issue  on Bamboo  or Elcodi  if you found any bug.\nAny collaboration is welcome! We look forward to hearing from you!", 
            "title": "Installation"
        }, 
        {
            "location": "/quick-start/#tests", 
            "text": "Yes, we are doing some tests, and this will be  in cresciendo . You can ensure\nyourself that all the cases we've been working on are actually green. We are\nusing Behat and PHPUnit, so you only need to execute all suites by using this\npiece of code.  $ php bin/behat\n$ php bin/phpunit -c app\n$ php app/console visithor:go --format=pretty --env=test", 
            "title": "Tests"
        }, 
        {
            "location": "/quick-start/#issues", 
            "text": "You can report any issue on  Bamboo  or Elcodi", 
            "title": "Issues"
        }, 
        {
            "location": "/quick-start/#need-help", 
            "text": "If you need any help with the installation or understanding elcodi or bamboo you\ncan contact us on  gitter .\nWe will be glad to help you, just ask for help.", 
            "title": "Need help"
        }, 
        {
            "location": "/reference/attribute/", 
            "text": "AttributeBundle Reference\n\n\nelcodi_attribute:\n\n    mapping:\n        attribute:\n            # Attribute entity implementing AttributeInterface\n            class: Elcodi\\Component\\Attribute\\Entity\\Attribute\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiAttributeBundle/Resources/config/doctrine/Attribute.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        value:\n            # Value entity implementing ValueInterface\n            class: Elcodi\\Component\\Attribute\\Entity\\Value\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiAttributeBundle/Resources/config/doctrine/Value.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "Attribute"
        }, 
        {
            "location": "/reference/attribute/#attributebundle-reference", 
            "text": "elcodi_attribute:\n\n    mapping:\n        attribute:\n            # Attribute entity implementing AttributeInterface\n            class: Elcodi\\Component\\Attribute\\Entity\\Attribute\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiAttributeBundle/Resources/config/doctrine/Attribute.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        value:\n            # Value entity implementing ValueInterface\n            class: Elcodi\\Component\\Attribute\\Entity\\Value\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiAttributeBundle/Resources/config/doctrine/Value.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "AttributeBundle Reference"
        }, 
        {
            "location": "/reference/banner/", 
            "text": "BannerBundle Reference\n\n\nelcodi_banner:\n\n    mapping:\n        banner:\n            # Banner entity implementing BannerInterface\n            class: Elcodi\\Component\\Banner\\Entity\\Banner\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiBannerBundle/Resources/config/doctrine/Banner.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        banner_zone:\n            # BannerZone entity implementing BannerZoneInterface\n            class: Elcodi\\Component\\Banner\\Entity\\BannerZone\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiBannerBundle/Resources/config/doctrine/BannerZone.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "Banner"
        }, 
        {
            "location": "/reference/banner/#bannerbundle-reference", 
            "text": "elcodi_banner:\n\n    mapping:\n        banner:\n            # Banner entity implementing BannerInterface\n            class: Elcodi\\Component\\Banner\\Entity\\Banner\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiBannerBundle/Resources/config/doctrine/Banner.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        banner_zone:\n            # BannerZone entity implementing BannerZoneInterface\n            class: Elcodi\\Component\\Banner\\Entity\\BannerZone\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiBannerBundle/Resources/config/doctrine/BannerZone.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "BannerBundle Reference"
        }, 
        {
            "location": "/reference/cart-coupon/", 
            "text": "CartCouponBundle Reference\n\n\nelcodi_cart_coupon:\n\n    mapping:\n        cart_coupon:\n            # CartCoupon entity implementing CartCouponInterface\n            class: Elcodi\\Component\\CartCoupon\\Entity\\CartCoupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartCouponBundle/Resources/config/doctrine/CartCoupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order_coupon:\n            # OrderCoupon entity implementing OrderCouponInterface\n            class: Elcodi\\Component\\CartCoupon\\Entity\\OrderCoupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartCouponBundle/Resources/config/doctrine/OrderCoupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "Cart coupon"
        }, 
        {
            "location": "/reference/cart-coupon/#cartcouponbundle-reference", 
            "text": "elcodi_cart_coupon:\n\n    mapping:\n        cart_coupon:\n            # CartCoupon entity implementing CartCouponInterface\n            class: Elcodi\\Component\\CartCoupon\\Entity\\CartCoupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartCouponBundle/Resources/config/doctrine/CartCoupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order_coupon:\n            # OrderCoupon entity implementing OrderCouponInterface\n            class: Elcodi\\Component\\CartCoupon\\Entity\\OrderCoupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartCouponBundle/Resources/config/doctrine/OrderCoupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "CartCouponBundle Reference"
        }, 
        {
            "location": "/reference/cart/", 
            "text": "CartBundle Reference\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Cart\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Cart.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        cart_line:\n            # CartLine entity implementing CartLineInterface\n            class: Elcodi\\Component\\Cart\\Entity\\CartLine\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/CartLine.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order:\n            # Order entity implementing OrderInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Order\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Order.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order_line:\n            # OrderLine entity implementing OrderLineInterface\n            class: Elcodi\\Component\\Cart\\Entity\\OrderLine\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/OrderLine.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    # Cart related configuration\n    cart:\n        # Your cart is saved in session\n        save_in_session: true\n        # If your cart is saved in session, what's the field name?\n        Session_field_name: cart_id\n\n    # You can define a set of states inside the payment machine\n    # This machine is used as the payment workflow guide\n    payment_states_machine:\n        # Name for this machine in order to be cached\n        identifier: order_payment_states_machine\n        # Which state will be the first one? Take in account that such state \n        # will be added automatically once the order is created\n        point_of_entry: unpaid\n        # Set of states conforming this machine\n        states:\n            - [\nunpaid\n, \npay\n, \npaid\n]\n            - [\npaid\n, \nrefund\n, \nrefunded\n]\n\n    # You can define a set of states inside the shipping machine\n    # This machine is used as the shipping workflow guide\n    shipping_states_machine:\n        # Name for this machine in order to be cached\n        identifier: order_shipping_states_machine\n        # Which state will be the first one? Take in account that such state \n        # will be added automatically once the order is created\n        point_of_entry: not shipped\n        # Set of states conforming this machine\n        states:\n            - [\nnot shipped\n, \nship\n, \nshipped\n]", 
            "title": "Cart"
        }, 
        {
            "location": "/reference/cart/#cartbundle-reference", 
            "text": "elcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Cart\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Cart.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        cart_line:\n            # CartLine entity implementing CartLineInterface\n            class: Elcodi\\Component\\Cart\\Entity\\CartLine\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/CartLine.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order:\n            # Order entity implementing OrderInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Order\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Order.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        order_line:\n            # OrderLine entity implementing OrderLineInterface\n            class: Elcodi\\Component\\Cart\\Entity\\OrderLine\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/OrderLine.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    # Cart related configuration\n    cart:\n        # Your cart is saved in session\n        save_in_session: true\n        # If your cart is saved in session, what's the field name?\n        Session_field_name: cart_id\n\n    # You can define a set of states inside the payment machine\n    # This machine is used as the payment workflow guide\n    payment_states_machine:\n        # Name for this machine in order to be cached\n        identifier: order_payment_states_machine\n        # Which state will be the first one? Take in account that such state \n        # will be added automatically once the order is created\n        point_of_entry: unpaid\n        # Set of states conforming this machine\n        states:\n            - [ unpaid ,  pay ,  paid ]\n            - [ paid ,  refund ,  refunded ]\n\n    # You can define a set of states inside the shipping machine\n    # This machine is used as the shipping workflow guide\n    shipping_states_machine:\n        # Name for this machine in order to be cached\n        identifier: order_shipping_states_machine\n        # Which state will be the first one? Take in account that such state \n        # will be added automatically once the order is created\n        point_of_entry: not shipped\n        # Set of states conforming this machine\n        states:\n            - [ not shipped ,  ship ,  shipped ]", 
            "title": "CartBundle Reference"
        }, 
        {
            "location": "/reference/comment/", 
            "text": "Comment Reference\n\n\nelcodi_comment:\n\n    mapping:\n        comment:\n            # Comment entity implementing CommentInterface\n            class: Elcodi\\Component\\Comment\\Entity\\Comment\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCommentBundle/Resources/config/doctrine/Comment.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        comment_vote:\n            # Vote entity implementing VoteInterface\n            class: Elcodi\\Component\\Comment\\Entity\\Vote\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCommentBundle/Resources/config/doctrine/Vote.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    comments:\n        # Your comments will be cached, so maybe you want to customize the key\n        cache_key: comments\n        # A comment can be parsed. Check the possible parsers and chose yours\n        # Take in account that this value must be a service name\n        parser: elcodi.dummy_parser_adapter", 
            "title": "Comment"
        }, 
        {
            "location": "/reference/comment/#comment-reference", 
            "text": "elcodi_comment:\n\n    mapping:\n        comment:\n            # Comment entity implementing CommentInterface\n            class: Elcodi\\Component\\Comment\\Entity\\Comment\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCommentBundle/Resources/config/doctrine/Comment.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n        comment_vote:\n            # Vote entity implementing VoteInterface\n            class: Elcodi\\Component\\Comment\\Entity\\Vote\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCommentBundle/Resources/config/doctrine/Vote.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    comments:\n        # Your comments will be cached, so maybe you want to customize the key\n        cache_key: comments\n        # A comment can be parsed. Check the possible parsers and chose yours\n        # Take in account that this value must be a service name\n        parser: elcodi.dummy_parser_adapter", 
            "title": "Comment Reference"
        }, 
        {
            "location": "/reference/configuration/", 
            "text": "Configuration Reference\n\n\nelcodi_configuration:\n\n    mapping:\n        configuration:\n            # Configuration entity implementing ConfigurationInterface\n            class: Elcodi\\Component\\Configuration\\Entity\\Configuration\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiConfigurationBundle/Resources/config/doctrine/Configuration.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    # Set of configuration elements. Each one can be defined as parameter-based\n    # configuration item, or not\n    elements:\n        my_configuration_item:\n            # Configuration item key\n            key: // required, for example \nitem\n\n            # Configuration item name\n            name: // required, for example \nItem\n\n            # Configuration item namespace.\n            namespace: ''\n            # You can define the type of this value. Chose between boolean,\n            # string, text or array\n            type: // required, for example \nstring\n\n            # You can reference a parameter by setting its name\n            reference: ~\n            # Default value for when is not defined\n            default_value: ~\n            # This configuration element can be empty\n            can_be_empty: true\n            # When cannot be empty and not value is found, you can define what\n            # message you want to show\n            empty_message: ''\n            # Read-only. This value cannot be modified or altered in database\n            read_only: false", 
            "title": "Configuration"
        }, 
        {
            "location": "/reference/configuration/#configuration-reference", 
            "text": "elcodi_configuration:\n\n    mapping:\n        configuration:\n            # Configuration entity implementing ConfigurationInterface\n            class: Elcodi\\Component\\Configuration\\Entity\\Configuration\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiConfigurationBundle/Resources/config/doctrine/Configuration.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n    # Set of configuration elements. Each one can be defined as parameter-based\n    # configuration item, or not\n    elements:\n        my_configuration_item:\n            # Configuration item key\n            key: // required, for example  item \n            # Configuration item name\n            name: // required, for example  Item \n            # Configuration item namespace.\n            namespace: ''\n            # You can define the type of this value. Chose between boolean,\n            # string, text or array\n            type: // required, for example  string \n            # You can reference a parameter by setting its name\n            reference: ~\n            # Default value for when is not defined\n            default_value: ~\n            # This configuration element can be empty\n            can_be_empty: true\n            # When cannot be empty and not value is found, you can define what\n            # message you want to show\n            empty_message: ''\n            # Read-only. This value cannot be modified or altered in database\n            read_only: false", 
            "title": "Configuration Reference"
        }, 
        {
            "location": "/reference/coupon/", 
            "text": "CouponBundle Reference\n\n\nelcodi_coupon:\n\n    mapping:\n        coupon:\n            # Coupon entity implementing CouponInterface\n            class: Elcodi\\Component\\Coupon\\Entity\\Coupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCouponBundle/Resources/config/doctrine/Coupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "Coupon"
        }, 
        {
            "location": "/reference/coupon/#couponbundle-reference", 
            "text": "elcodi_coupon:\n\n    mapping:\n        coupon:\n            # Coupon entity implementing CouponInterface\n            class: Elcodi\\Component\\Coupon\\Entity\\Coupon\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCouponBundle/Resources/config/doctrine/Coupon.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true", 
            "title": "CouponBundle Reference"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference\n\n\nEver wondered what configuration options you have available to you in files such \nas app/config/config.yml? In this section, all the available configuration is \nbroken down by the key (e.g. elcodi_product) that defines each possible section \nof your Elcodi configuration.\n\n\n\n\nAttribute\n\n\nBanner\n\n\nCart\n\n\nCartCoupon\n\n\nComment\n\n\nConfiguration\n\n\nCoupon\n\n\nSitemap", 
            "title": "Home"
        }, 
        {
            "location": "/reference/#reference", 
            "text": "Ever wondered what configuration options you have available to you in files such \nas app/config/config.yml? In this section, all the available configuration is \nbroken down by the key (e.g. elcodi_product) that defines each possible section \nof your Elcodi configuration.   Attribute  Banner  Cart  CartCoupon  Comment  Configuration  Coupon  Sitemap", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/sitemap/", 
            "text": "SitemapBundle Reference\n\n\nelcodi_sitemap:\n\n    # Each block defines a way of creating dynamically a set of elements of a\n    # sitemap file, each one mapped from a database entry\n    blocks:\n        enabled_products:\n            # Transformer\n            transformer: ~\n            # Repository service used for retrieving the array of entities\n            repository_service: elcodi.repository.product\n            # Repository method\n            method: findBy\n            # Array of arguments for the repository call\n            arguments:\n                enabled: true\n            # Specific change frequency for this block\n            changeFrequency: ~\n            # Specific priority for this block\n            priority: ~\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~\n\n    # A builder is a set of blocks and statics, grouped and saved in a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n                - enabled_categories\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main", 
            "title": "Sitemap"
        }, 
        {
            "location": "/reference/sitemap/#sitemapbundle-reference", 
            "text": "elcodi_sitemap:\n\n    # Each block defines a way of creating dynamically a set of elements of a\n    # sitemap file, each one mapped from a database entry\n    blocks:\n        enabled_products:\n            # Transformer\n            transformer: ~\n            # Repository service used for retrieving the array of entities\n            repository_service: elcodi.repository.product\n            # Repository method\n            method: findBy\n            # Array of arguments for the repository call\n            arguments:\n                enabled: true\n            # Specific change frequency for this block\n            changeFrequency: ~\n            # Specific priority for this block\n            priority: ~\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~\n\n    # A builder is a set of blocks and statics, grouped and saved in a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n                - enabled_categories\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main", 
            "title": "SitemapBundle Reference"
        }, 
        {
            "location": "/components/attribute/", 
            "text": "Attribute\n\n\nCreate different product attributes and values.\n\n\n\n\nBundle Documentation\n\n\nGithub Repository\n\n\n\n\nUsage\n\n\nIn defining your products you would often create items that distinguish \nthemselves by a specific characteristic. If it is clothes you know there can be \nsizes, colors, types of packaging, etc. You can have for instance used state for \nbooks. So you would have books that are used, new, as new, or refurbished, etc. \nIn reality you would first come with the store and later your requirements will \nchange or adapt. If a product needs any of such characteristic to be highlighted \nat the moment of purchase then we know that we are before a usage for the \nattribute component.\n\n\nBecause they can change rapidly, these attributes are not good to model in code\nbut they must be modeled via database entries as we see here.\n\n\nLet's take the example of clothing sizes and define a size attribute with\nthree values as follows:\n\n\n$attribute = $attributeDirector\n    -\ncreate()\n    -\nsetName('Woman Clothing Sizes')\n    -\nsetEnabled(true);\n\n$attributeDirector-\nsave($attribute);\n\nforeach (['Small', 'Medium', 'Large'] as $size) {\n    $value = $attributeValueDirector\n        -\ncreate()\n        -\nsetValue($size)\n        -\nsetAttribute($sizeAttribute);\n\n    $attributeValueDirector-\nsave($value);\n}\n\n\n\n\nFrom the structured data that we have created we can then handle these\nclothing sizes to enrich the handling of products.\n\n\n$sizes = $attributeRepository-\nfindBy(['name' =\n 'Woman Clothing Sizes']);\n\n// validate or select a size from the set ...\n\n\n\n\nThe component is tightly integrated with the bundle of the same name. The \nclasses that the bundle uses, the services used in the example above, are in the \ncomponent whereas the service definitions are declared in the bundle.\n\n\nApart from this, the component is mainly built from the Attribute and the Value \nobjects. They relate together bidirectionally on its default mapping, though \nthis can be overridden.\n\n\nAn Attribute bears a name and can find its value representations and Values are \nalways mapping back to the Attribute for which they determine a representation.\nAn Attribute has temporal features meaning that the entity tracks time for when\nit was created and when it is updated and also can be enabled or disabled.\nThe same is not true for any Value for that Attribute.\n\n\nExample you can find out when the attribute Color was created or modified\nbut you cannot know when blue value was added or updated. Therefore, you\ncan find out when we got sizes for a product but not when we got sizes of\nsmall or extra large for the products in the store.\n\n\nOf course these limitations if needed can be overcame by simple overriding\nthe mapping.", 
            "title": "Attribute"
        }, 
        {
            "location": "/components/attribute/#attribute", 
            "text": "Create different product attributes and values.   Bundle Documentation  Github Repository", 
            "title": "Attribute"
        }, 
        {
            "location": "/components/attribute/#usage", 
            "text": "In defining your products you would often create items that distinguish \nthemselves by a specific characteristic. If it is clothes you know there can be \nsizes, colors, types of packaging, etc. You can have for instance used state for \nbooks. So you would have books that are used, new, as new, or refurbished, etc. \nIn reality you would first come with the store and later your requirements will \nchange or adapt. If a product needs any of such characteristic to be highlighted \nat the moment of purchase then we know that we are before a usage for the \nattribute component.  Because they can change rapidly, these attributes are not good to model in code\nbut they must be modeled via database entries as we see here.  Let's take the example of clothing sizes and define a size attribute with\nthree values as follows:  $attribute = $attributeDirector\n    - create()\n    - setName('Woman Clothing Sizes')\n    - setEnabled(true);\n\n$attributeDirector- save($attribute);\n\nforeach (['Small', 'Medium', 'Large'] as $size) {\n    $value = $attributeValueDirector\n        - create()\n        - setValue($size)\n        - setAttribute($sizeAttribute);\n\n    $attributeValueDirector- save($value);\n}  From the structured data that we have created we can then handle these\nclothing sizes to enrich the handling of products.  $sizes = $attributeRepository- findBy(['name' =  'Woman Clothing Sizes']);\n\n// validate or select a size from the set ...  The component is tightly integrated with the bundle of the same name. The \nclasses that the bundle uses, the services used in the example above, are in the \ncomponent whereas the service definitions are declared in the bundle.  Apart from this, the component is mainly built from the Attribute and the Value \nobjects. They relate together bidirectionally on its default mapping, though \nthis can be overridden.  An Attribute bears a name and can find its value representations and Values are \nalways mapping back to the Attribute for which they determine a representation.\nAn Attribute has temporal features meaning that the entity tracks time for when\nit was created and when it is updated and also can be enabled or disabled.\nThe same is not true for any Value for that Attribute.  Example you can find out when the attribute Color was created or modified\nbut you cannot know when blue value was added or updated. Therefore, you\ncan find out when we got sizes for a product but not when we got sizes of\nsmall or extra large for the products in the store.  Of course these limitations if needed can be overcame by simple overriding\nthe mapping.", 
            "title": "Usage"
        }, 
        {
            "location": "/components/entity-translator/", 
            "text": "Entity Translator\n\n\nTranslate your entities in a very decoupled way.\n\n\n\n\nBundle Documentation\n\n\nGithub Repository\n\n\n\n\nUsage\n\n\nThe model is the most important part of a project, right? We strongly believe\nthat, so we think that coupling the entities with the translation infrastructure\nis a bad practice.\n\n\nThis component provides an external translation engine with some nice services\nto make an entity translation something really easy and enjoyable.\n\n\nLet's figure out we are working with a Product object. Our model clean, with two\nfields: name and description. All this documentation assumes the usage of this\nclass.\n\n\n/**\n * Class Product\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n\n    /**\n     * Get Id\n     *\n     * @return string Id\n     */\n    public function getId()\n    {\n        return $this-\nid;\n    }\n\n    /**\n     * Sets Id\n     *\n     * @param string $id Id\n     *\n     * @return $this Self object\n     */\n    public function setId($id)\n    {\n        $this-\nid = $id;\n\n        return $this;\n    }\n\n    /**\n     * Get Name\n     *\n     * @return mixed Name\n     */\n    public function getName()\n    {\n        return $this-\nname;\n    }\n\n    /**\n     * Sets Name\n     *\n     * @param mixed $name Name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this-\nname = $name;\n\n        return $this;\n    }\n\n    /**\n     * Get Description\n     *\n     * @return string Description\n     */\n    public function getDescription()\n    {\n        return $this-\ndescription;\n    }\n\n    /**\n     * Sets Description\n     *\n     * @param string $description Description\n     *\n     * @return $this Self object\n     */\n    public function setDescription($description)\n    {\n        $this-\ndescription = $description;\n\n        return $this;\n    }\n}\n\n\n\n\nWe want to manage the translations of both properties. Important, each project\nneeds to define what fields must be translatable, this is not related to the\ncomponent itself.\n\n\nEntityTranslationProvider\n\n\nThe translation provider is responsible to connect with the persistent layer and\nprovide the results, using an specific format, to the managers and services.\n\n\n/**\n * Interface EntityTranslationProviderInterface\n */\ninterface EntityTranslationProviderInterface\n{\n    /**\n     * Get translation\n     *\n     * @param string $entityType  Type of entity\n     * @param string $entityId    Id of entity\n     * @param string $entityField Field of entity\n     * @param string $locale      Locale\n     *\n     * @return string Value fetched\n     */\n    public function getTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $locale\n    );\n\n    /**\n     * Set translation\n     *\n     * @param string $entityType       Type of entity\n     * @param string $entityId         Id of entity\n     * @param string $entityField      Field of entity\n     * @param string $translationValue Translated value\n     * @param string $locale           Locale\n     *\n     * @return string Value fetched\n     */\n    public function setTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $translationValue,\n        $locale\n    );\n\n    /**\n     * Flush all previously set translations.\n     *\n     * @return $this self Object\n     */\n    public function flushTranslations();\n}\n\n\n\n\nThere is the possibility of using specific providers for some specific\ndecorations, for example, the \nCachedEntityTranslationProvider\n implementation,\nthat decorates the main provider by adding an extra cache layer.\n\n\nEntityTranslatorBuilder\n\n\nTranslation configuration is not set on the fly. It means that a Translator\nneeds to know what entities and what fields must take in account for\ntranslations.\n\n\nFor that reason we need to build the translator using a TranslatorBuilder.\n\n\n$entityTranslationProvider;\n$entityTranslatorFactory = new TranslatorFactory();\n$entityTranslator = $this-\ngetMock(\n    'Elcodi\\Component\\EntityTranslator\\Services\\EntityTranslator', \n    [], \n    [], \n    '', \n    false\n);\n\n$configuration = [\n    'Elcodi\\Component\\EntityTranslator\\Tests\\Fixtures\\TranslatableProduct' =\n [\n        'alias'  =\n 'product',\n        'idGetter' =\n 'getId',\n        'fields' =\n [\n            'name' =\n [\n                'setter' =\n 'setName',\n                'getter' =\n 'getName',\n            ]\n        ]\n    ],\n];\n\n$entityTranslatorBuilder = new EntityTranslatorBuilder(\n    $entityTranslationProvider,\n    $translatorFactory,\n    $configuration\n);\n$entityTranslator = $translatorBuilder-\ncompile();\n\n\n\n\nA compiled translator is, somehow, an immutable object. This means that,\ninternally, can change because of new instances, but externally can only be\naccessed by getters.\n\n\nEntityTranslator\n\n\nThe translator itself. This implementation enables you to work with entities\ninstead of translations.\n\n\n/**\n * Interface EntityTranslatorInterface\n */\ninterface EntityTranslatorInterface\n{\n    /**\n     * Translate object\n     *\n     * @param Object $object Object\n     * @param string $locale Locale to be translated\n     */\n    public function translate($object, $locale);\n\n    /**\n     * Saves object translations\n     *\n     * @param Object $object       Object\n     * @param array  $translations Translations\n     */\n    public function save($object, array $translations);\n}\n\n\n\n\nUsing the same configuration than before, lets see an example about how we can\nmanage our entity translations using this service.\n\n\n$product = new TranslatableProduct();\n$product\n    -\nsetId(1)\n    -\nsetName('productName');\n\n$entityTranslator-\nsave($product, [\n    'es' =\n [\n        'name' =\n 'el nombre',\n        'description' =\n 'la descripci\u00f3n',\n    ],\n    'en' =\n [\n        'name' =\n 'the name',\n        'description' =\n 'the description',\n        'anotherfield' =\n 'some value',\n    ],\n]);\n\n/**\n * At this point, all the data have been persisted to database and cached.\n * As you can see, the `translate` method returns the translated object, but\n * both objects are the same\n */\n\n$translatedProduct = $translator-\ntranslate($product, 'en');\n\n$translatedName = $translatedProduct-\ngetName();\necho $translatedName;\n// = \nthe name\n\n\n/**\n * So because both object are the same, you can just apply the translation\n * without using the returned object\n */\n\n$translator-\ntranslate($product, 'es');\n\n$translatedName = $product-\ngetName();\necho $translatedName;\n// = \nel nombre\n\n\n\n\n\n\nTo when you save all the translations of an entity, the \nEntityTranslator\n will\nmake a unique flush to the persistence layer, in order to improve this action.", 
            "title": "Entity translator"
        }, 
        {
            "location": "/components/entity-translator/#entity-translator", 
            "text": "Translate your entities in a very decoupled way.   Bundle Documentation  Github Repository", 
            "title": "Entity Translator"
        }, 
        {
            "location": "/components/entity-translator/#usage", 
            "text": "The model is the most important part of a project, right? We strongly believe\nthat, so we think that coupling the entities with the translation infrastructure\nis a bad practice.  This component provides an external translation engine with some nice services\nto make an entity translation something really easy and enjoyable.  Let's figure out we are working with a Product object. Our model clean, with two\nfields: name and description. All this documentation assumes the usage of this\nclass.  /**\n * Class Product\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n\n    /**\n     * Get Id\n     *\n     * @return string Id\n     */\n    public function getId()\n    {\n        return $this- id;\n    }\n\n    /**\n     * Sets Id\n     *\n     * @param string $id Id\n     *\n     * @return $this Self object\n     */\n    public function setId($id)\n    {\n        $this- id = $id;\n\n        return $this;\n    }\n\n    /**\n     * Get Name\n     *\n     * @return mixed Name\n     */\n    public function getName()\n    {\n        return $this- name;\n    }\n\n    /**\n     * Sets Name\n     *\n     * @param mixed $name Name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this- name = $name;\n\n        return $this;\n    }\n\n    /**\n     * Get Description\n     *\n     * @return string Description\n     */\n    public function getDescription()\n    {\n        return $this- description;\n    }\n\n    /**\n     * Sets Description\n     *\n     * @param string $description Description\n     *\n     * @return $this Self object\n     */\n    public function setDescription($description)\n    {\n        $this- description = $description;\n\n        return $this;\n    }\n}  We want to manage the translations of both properties. Important, each project\nneeds to define what fields must be translatable, this is not related to the\ncomponent itself.", 
            "title": "Usage"
        }, 
        {
            "location": "/components/entity-translator/#entitytranslationprovider", 
            "text": "The translation provider is responsible to connect with the persistent layer and\nprovide the results, using an specific format, to the managers and services.  /**\n * Interface EntityTranslationProviderInterface\n */\ninterface EntityTranslationProviderInterface\n{\n    /**\n     * Get translation\n     *\n     * @param string $entityType  Type of entity\n     * @param string $entityId    Id of entity\n     * @param string $entityField Field of entity\n     * @param string $locale      Locale\n     *\n     * @return string Value fetched\n     */\n    public function getTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $locale\n    );\n\n    /**\n     * Set translation\n     *\n     * @param string $entityType       Type of entity\n     * @param string $entityId         Id of entity\n     * @param string $entityField      Field of entity\n     * @param string $translationValue Translated value\n     * @param string $locale           Locale\n     *\n     * @return string Value fetched\n     */\n    public function setTranslation(\n        $entityType,\n        $entityId,\n        $entityField,\n        $translationValue,\n        $locale\n    );\n\n    /**\n     * Flush all previously set translations.\n     *\n     * @return $this self Object\n     */\n    public function flushTranslations();\n}  There is the possibility of using specific providers for some specific\ndecorations, for example, the  CachedEntityTranslationProvider  implementation,\nthat decorates the main provider by adding an extra cache layer.", 
            "title": "EntityTranslationProvider"
        }, 
        {
            "location": "/components/entity-translator/#entitytranslatorbuilder", 
            "text": "Translation configuration is not set on the fly. It means that a Translator\nneeds to know what entities and what fields must take in account for\ntranslations.  For that reason we need to build the translator using a TranslatorBuilder.  $entityTranslationProvider;\n$entityTranslatorFactory = new TranslatorFactory();\n$entityTranslator = $this- getMock(\n    'Elcodi\\Component\\EntityTranslator\\Services\\EntityTranslator', \n    [], \n    [], \n    '', \n    false\n);\n\n$configuration = [\n    'Elcodi\\Component\\EntityTranslator\\Tests\\Fixtures\\TranslatableProduct' =  [\n        'alias'  =  'product',\n        'idGetter' =  'getId',\n        'fields' =  [\n            'name' =  [\n                'setter' =  'setName',\n                'getter' =  'getName',\n            ]\n        ]\n    ],\n];\n\n$entityTranslatorBuilder = new EntityTranslatorBuilder(\n    $entityTranslationProvider,\n    $translatorFactory,\n    $configuration\n);\n$entityTranslator = $translatorBuilder- compile();  A compiled translator is, somehow, an immutable object. This means that,\ninternally, can change because of new instances, but externally can only be\naccessed by getters.", 
            "title": "EntityTranslatorBuilder"
        }, 
        {
            "location": "/components/entity-translator/#entitytranslator", 
            "text": "The translator itself. This implementation enables you to work with entities\ninstead of translations.  /**\n * Interface EntityTranslatorInterface\n */\ninterface EntityTranslatorInterface\n{\n    /**\n     * Translate object\n     *\n     * @param Object $object Object\n     * @param string $locale Locale to be translated\n     */\n    public function translate($object, $locale);\n\n    /**\n     * Saves object translations\n     *\n     * @param Object $object       Object\n     * @param array  $translations Translations\n     */\n    public function save($object, array $translations);\n}  Using the same configuration than before, lets see an example about how we can\nmanage our entity translations using this service.  $product = new TranslatableProduct();\n$product\n    - setId(1)\n    - setName('productName');\n\n$entityTranslator- save($product, [\n    'es' =  [\n        'name' =  'el nombre',\n        'description' =  'la descripci\u00f3n',\n    ],\n    'en' =  [\n        'name' =  'the name',\n        'description' =  'the description',\n        'anotherfield' =  'some value',\n    ],\n]);\n\n/**\n * At this point, all the data have been persisted to database and cached.\n * As you can see, the `translate` method returns the translated object, but\n * both objects are the same\n */\n\n$translatedProduct = $translator- translate($product, 'en');\n\n$translatedName = $translatedProduct- getName();\necho $translatedName;\n// =  the name \n\n/**\n * So because both object are the same, you can just apply the translation\n * without using the returned object\n */\n\n$translator- translate($product, 'es');\n\n$translatedName = $product- getName();\necho $translatedName;\n// =  el nombre   To when you save all the translations of an entity, the  EntityTranslator  will\nmake a unique flush to the persistence layer, in order to improve this action.", 
            "title": "EntityTranslator"
        }, 
        {
            "location": "/components/", 
            "text": "The Components\n\n\n\n\nAttribute\n\n\nEntity Translator\n\n\nState Transition Machine\n\n\nMenu", 
            "title": "Home"
        }, 
        {
            "location": "/components/#the-components", 
            "text": "Attribute  Entity Translator  State Transition Machine  Menu", 
            "title": "The Components"
        }, 
        {
            "location": "/components/menu/", 
            "text": "Menu\n\n\nCreate, manage and modify menus and nodes in a very simple and intuitive way.\n\n\n\n\nBundle Documentation\n\n\nGithub Repository\n\n\n\n\nThe main goal of this component is the decoupling between how a menu must be \ncreated by a project, and the way all leafs are generated, filtered and \nmodified, in order to give this responsibility to the actor who really has to\ndo it.\n\n\nStructure\n\n\nLet's see a simple view of how Menu is modeled\n\n\nMenu\n  |\n  |- Node1\n  |   |\n  |   |- Node2\n  |   |   |\n  |   |   |- Node3\n  |   |\n  |   |- Node4\n  |\n  |- Node5\n\n\n\n\nCreating a new Menu\n\n\nYou can create a new Menu with their MenuNodes just using their factories. Let's\nsee an example of how to build a structure.\n\n\nuse Elcodi\\Component\\Menu\\Factory\\MenuFactory;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n$menuNodeFactory = new NodeFactory();\n$menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n$menuNode = $menuFactory\n    -\ncreate()\n    -\nsetName('Dashboard')\n    -\nsetCode('dashboard')\n    -\nsetUrl('http://myurl.com')\n    -\nsetActiveUrls([\n        'http://myurl.com/admin'\n    ])\n    -\nsetEnabled(true);\n\n$menuFactory = new MenuFactory();\n$menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Menu');\n$menu = $menuFactory\n    -\ncreate()\n    -\nsetName('admin')\n    -\nsetDescription('Admin menu')\n    -\nsetEnabled(true)\n    -\naddSubnode($menuNode);\n\n\n\n\nManaging menus\n\n\nUsing the class \nMenuManager\n you will be able to manage your menus. This \nmanager is not simple, so has the responsibility to manage all menus using local\ncache, Doctrine cache and Database repository.\n\n\nuse Doctrine\\Common\\Cache\\CacheProvider;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nuse Elcodi\\Component\\Core\\Encoder\\Interfaces\\EncoderInterface;\nuse Elcodi\\Component\\Menu\\Repository\\MenuRepository;\n\n$menuRepository = ...; // MenuRepository\n$menuObjectManager = ...; // ObjectManager\n$menuCache = ...; // CacheProvider\n$menuEncoder = ...; //EncoderInterface\n$menuCacheKey = 'menus';\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder);\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nEach menu, once loaded from database, is detached in a cascade mode. It means\nthat you cannot modify a menu using any kind of event and save it into database.\n\n\nLets see how a menu can be changed on the fly.\n\n\n\n\nSince now, when we refer to a Changer element, we are referring to Filters,\nModifiers or Builders\n\n\n\n\nCache\n\n\nOf course this component is built on top of a simple cache layer, so each time \na new menu is loaded from database, there are two different stages: before the \nmenu is cached \nElcodiMenuStages::BEFORE_CACHE\n and after the menu is cached \n\nElcodiMenuStages::AFTER_CACHE\n.\n\n\nThe difference is that when you apply a changer before the result is cached, \nthose changes will be reused until the menu is removed from the cache and \nrebuilt again.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n\n\n\nSo, if one specific filter, a builder or a modifier must be executed in every\nrequest, then must be defined as the after-cache stage.\n\n\nSpecific menus\n\n\nWhen we add a changer element, we can specify a set of menu elements where we\nwant this changes to be applied to. You can as well apply them to all menus, so\nthis parameter should be an empty array.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin', 'store'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n\n\n\nIn that case, we are setting that our filter should only be applied to menus \ncalled \nadmin\n and \nstore\n.\n\n\nPriority\n\n\nOnce we have several changers, then we can prioritize them by using priority\nparameter.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n$menuFilterer\n    -\naddMenuFilter(\n        new AnotherMenuFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        10\n    );\n\n\n\n\nIn that case, and because more priority means earlier execution, filter\n\nAnotherMenuFilter\n will be executed before than filter \nMenuDisabledFilter\n.\n\n\nFiltering menus\n\n\nYou can filter existing menus. It means that, considering any node, one by one,\nyou can decide if this node (and all subnodes) must continue being inside the \nmenu.\n\n\nIf a node is considered as invalid, then all subnodes will, automatically, \ntreated as invalids.\n\n\nLet's see an example of a MenuFilter that removed a node if this one is not \nenabled.\n\n\nuse Elcodi\\Component\\Menu\\Filter\\Interfaces\\MenuFilterInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\n\n/**\n * Class MenuDisabledFilter\n */\nclass MenuDisabledFilter implements MenuFilterInterface\n{\n    /**\n     * Filter a node once this has to be rendered\n     *\n     * @param NodeInterface $menuNode Menu node\n     *\n     * @return boolean Node must be rendered\n     */\n    public function filter(NodeInterface $menuNode)\n    {\n        return $menuNode-\nisEnabled();\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time. In this example we will add a filter that will check \nwhen a menu is disabled in database. Then this menu node should be removed from\nthe tree.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuFilterer;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    -\naddMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuFilterer)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nIf we check the menu tree, then we could draw something like that\n\n\nMenu\n  |\n  |- Node1 \nenabled\n\n  |   |\n  |   |- Node2 \ndisabled\n\n  |   |   |\n  |   |   |- Node3 \nenabled\n\n  |   |\n  |   |- Node4 \nenabled\n\n  |\n  |- Node5 \ndisabled\n\n\n\n\n\nSo after applying this filters, we will have this menu\n\n\nMenu\n  |\n  |- Node1 \nenabled\n\n      |\n      |- Node4 \nenabled\n\n\n\n\n\nBuilding menus\n\n\nOnce the menu is requested from the repository and detached from the object\nmanager, you can add more nodes in order to configure it.\n\n\nLet's see an example that adds a new Node inside the Node dashboard. For this,\nboth entities Menu and Node have a method called \nfindNodeByKey\n that returns,\nif exists, the Node with given code, looking for inside all subnodes, \nrecursively.\n\n\nuse Elcodi\\Component\\Menu\\Builder\\Interfaces\\MenuBuilderInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n/**\n * Class MenuBuilderUser\n */\nclass MenuBuilderUser implements MenuBuilderInterface\n{\n    /**\n     * Build the menu\n     *\n     * @param MenuInterface $menu Menu\n     */\n    public function build(MenuInterface $menuNode)\n    {\n        $menuNodeFactory = new NodeFactory();\n        $menuFactory-\nsetEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n        $userNode = $menuNodeFactory\n            -\ncreate()\n            -\nsetName('User')\n            -\nsetCode('user')\n            -\nsetUrl('http://myurl.com/admin/user')\n            -\nsetEnabled(true);\n\n        $dashboardNode = $menu-\nfindSubnodeByName('Dashboard');\n\n        if ($dashboardNode instanceof NodeInterface) {\n            $dashboardNode-\naddSubnode($userNode);\n        }\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuBuilder;\n\n$menuBuilder = new MenuBuilder();\n$menuBuilder\n    -\naddMenuBuilder(\n        new MenuBuilderUser(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuBuilder)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');\n\n\n\n\nModifying menus\n\n\nMaybe you want to modify a single menu. For this you can use the Menu Modifiers,\na type of changer that is intended, only, for single Menu Node modifications.\n\n\nLet's see an example that sets \nactive\n as true if, given a Request object, \ncurrent route matches any of specified as active routes.\n\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Modifier\\Interfaces\\MenuModifierInterface;\n\n/**\n * Class MenuActiveModifier\n */\nclass MenuActiveModifier implements MenuModifierInterface\n{\n    /**\n     * Modifier the menu node\n     *\n     * @param NodeInterface $menuNode Menu node\n     */\n    public function modify(NodeInterface $menuNode)\n    {\n        $request = ...; // Request\n\n        $currentRoute = $request-\nget('_route');\n\n        if (in_array($currentRoute, $menuNode-\ngetActiveUrls())) {\n            $menuNode-\nsetActive(true);\n        }\n    }\n}\n\n\n\n\nThen you must add this changer once your manager is instanced in order to use it\nin Menu building time.\n\n\nuse Elcodi\\Component\\Menu\\Services\\MenuModifier;\n\n$menuModifier = new MenuModifier();\n$menuModifier\n    -\naddMenuModifier(\n        new MenuActiveModifier(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    -\nsetCache($menuCache)\n    -\nsetEncoder($menuEncoder)\n    -\naddMenuChanger($menuModifier)\n\n$adminMenu = $menuManager-\nloadMenuByCode('admin');", 
            "title": "Menu"
        }, 
        {
            "location": "/components/menu/#menu", 
            "text": "Create, manage and modify menus and nodes in a very simple and intuitive way.   Bundle Documentation  Github Repository   The main goal of this component is the decoupling between how a menu must be \ncreated by a project, and the way all leafs are generated, filtered and \nmodified, in order to give this responsibility to the actor who really has to\ndo it.", 
            "title": "Menu"
        }, 
        {
            "location": "/components/menu/#structure", 
            "text": "Let's see a simple view of how Menu is modeled  Menu\n  |\n  |- Node1\n  |   |\n  |   |- Node2\n  |   |   |\n  |   |   |- Node3\n  |   |\n  |   |- Node4\n  |\n  |- Node5", 
            "title": "Structure"
        }, 
        {
            "location": "/components/menu/#creating-a-new-menu", 
            "text": "You can create a new Menu with their MenuNodes just using their factories. Let's\nsee an example of how to build a structure.  use Elcodi\\Component\\Menu\\Factory\\MenuFactory;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n$menuNodeFactory = new NodeFactory();\n$menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n$menuNode = $menuFactory\n    - create()\n    - setName('Dashboard')\n    - setCode('dashboard')\n    - setUrl('http://myurl.com')\n    - setActiveUrls([\n        'http://myurl.com/admin'\n    ])\n    - setEnabled(true);\n\n$menuFactory = new MenuFactory();\n$menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Menu');\n$menu = $menuFactory\n    - create()\n    - setName('admin')\n    - setDescription('Admin menu')\n    - setEnabled(true)\n    - addSubnode($menuNode);", 
            "title": "Creating a new Menu"
        }, 
        {
            "location": "/components/menu/#managing-menus", 
            "text": "Using the class  MenuManager  you will be able to manage your menus. This \nmanager is not simple, so has the responsibility to manage all menus using local\ncache, Doctrine cache and Database repository.  use Doctrine\\Common\\Cache\\CacheProvider;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nuse Elcodi\\Component\\Core\\Encoder\\Interfaces\\EncoderInterface;\nuse Elcodi\\Component\\Menu\\Repository\\MenuRepository;\n\n$menuRepository = ...; // MenuRepository\n$menuObjectManager = ...; // ObjectManager\n$menuCache = ...; // CacheProvider\n$menuEncoder = ...; //EncoderInterface\n$menuCacheKey = 'menus';\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder);\n\n$adminMenu = $menuManager- loadMenuByCode('admin');  Each menu, once loaded from database, is detached in a cascade mode. It means\nthat you cannot modify a menu using any kind of event and save it into database.  Lets see how a menu can be changed on the fly.   Since now, when we refer to a Changer element, we are referring to Filters,\nModifiers or Builders", 
            "title": "Managing menus"
        }, 
        {
            "location": "/components/menu/#cache", 
            "text": "Of course this component is built on top of a simple cache layer, so each time \na new menu is loaded from database, there are two different stages: before the \nmenu is cached  ElcodiMenuStages::BEFORE_CACHE  and after the menu is cached  ElcodiMenuStages::AFTER_CACHE .  The difference is that when you apply a changer before the result is cached, \nthose changes will be reused until the menu is removed from the cache and \nrebuilt again.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );  So, if one specific filter, a builder or a modifier must be executed in every\nrequest, then must be defined as the after-cache stage.", 
            "title": "Cache"
        }, 
        {
            "location": "/components/menu/#specific-menus", 
            "text": "When we add a changer element, we can specify a set of menu elements where we\nwant this changes to be applied to. You can as well apply them to all menus, so\nthis parameter should be an empty array.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin', 'store'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );  In that case, we are setting that our filter should only be applied to menus \ncalled  admin  and  store .", 
            "title": "Specific menus"
        }, 
        {
            "location": "/components/menu/#priority", 
            "text": "Once we have several changers, then we can prioritize them by using priority\nparameter.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\nuse Elcodi\\Component\\Menu\\ElcodiMenuStages;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n$menuFilterer\n    - addMenuFilter(\n        new AnotherMenuFilter(),\n        ['admin'],\n        ElcodiMenuStages::BEFORE_CACHE,\n        10\n    );  In that case, and because more priority means earlier execution, filter AnotherMenuFilter  will be executed before than filter  MenuDisabledFilter .", 
            "title": "Priority"
        }, 
        {
            "location": "/components/menu/#filtering-menus", 
            "text": "You can filter existing menus. It means that, considering any node, one by one,\nyou can decide if this node (and all subnodes) must continue being inside the \nmenu.  If a node is considered as invalid, then all subnodes will, automatically, \ntreated as invalids.  Let's see an example of a MenuFilter that removed a node if this one is not \nenabled.  use Elcodi\\Component\\Menu\\Filter\\Interfaces\\MenuFilterInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\n\n/**\n * Class MenuDisabledFilter\n */\nclass MenuDisabledFilter implements MenuFilterInterface\n{\n    /**\n     * Filter a node once this has to be rendered\n     *\n     * @param NodeInterface $menuNode Menu node\n     *\n     * @return boolean Node must be rendered\n     */\n    public function filter(NodeInterface $menuNode)\n    {\n        return $menuNode- isEnabled();\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time. In this example we will add a filter that will check \nwhen a menu is disabled in database. Then this menu node should be removed from\nthe tree.  use Elcodi\\Component\\Menu\\Services\\MenuFilterer;\n\n$menuFilterer = new MenuFilterer();\n$menuFilterer\n    - addMenuFilter(\n        new MenuDisabledFilter(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuFilterer)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');  If we check the menu tree, then we could draw something like that  Menu\n  |\n  |- Node1  enabled \n  |   |\n  |   |- Node2  disabled \n  |   |   |\n  |   |   |- Node3  enabled \n  |   |\n  |   |- Node4  enabled \n  |\n  |- Node5  disabled   So after applying this filters, we will have this menu  Menu\n  |\n  |- Node1  enabled \n      |\n      |- Node4  enabled", 
            "title": "Filtering menus"
        }, 
        {
            "location": "/components/menu/#building-menus", 
            "text": "Once the menu is requested from the repository and detached from the object\nmanager, you can add more nodes in order to configure it.  Let's see an example that adds a new Node inside the Node dashboard. For this,\nboth entities Menu and Node have a method called  findNodeByKey  that returns,\nif exists, the Node with given code, looking for inside all subnodes, \nrecursively.  use Elcodi\\Component\\Menu\\Builder\\Interfaces\\MenuBuilderInterface;\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Factory\\NodeFactory;\n\n/**\n * Class MenuBuilderUser\n */\nclass MenuBuilderUser implements MenuBuilderInterface\n{\n    /**\n     * Build the menu\n     *\n     * @param MenuInterface $menu Menu\n     */\n    public function build(MenuInterface $menuNode)\n    {\n        $menuNodeFactory = new NodeFactory();\n        $menuFactory- setEntityNamespace('Elcodi\\Component\\Menu\\Entity\\Menu\\Node');\n        $userNode = $menuNodeFactory\n            - create()\n            - setName('User')\n            - setCode('user')\n            - setUrl('http://myurl.com/admin/user')\n            - setEnabled(true);\n\n        $dashboardNode = $menu- findSubnodeByName('Dashboard');\n\n        if ($dashboardNode instanceof NodeInterface) {\n            $dashboardNode- addSubnode($userNode);\n        }\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time.  use Elcodi\\Component\\Menu\\Services\\MenuBuilder;\n\n$menuBuilder = new MenuBuilder();\n$menuBuilder\n    - addMenuBuilder(\n        new MenuBuilderUser(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuBuilder)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');", 
            "title": "Building menus"
        }, 
        {
            "location": "/components/menu/#modifying-menus", 
            "text": "Maybe you want to modify a single menu. For this you can use the Menu Modifiers,\na type of changer that is intended, only, for single Menu Node modifications.  Let's see an example that sets  active  as true if, given a Request object, \ncurrent route matches any of specified as active routes.  use Symfony\\Component\\HttpFoundation\\Request;\n\nuse Elcodi\\Component\\Menu\\Entity\\Menu\\Interfaces\\NodeInterface;\nuse Elcodi\\Component\\Menu\\Modifier\\Interfaces\\MenuModifierInterface;\n\n/**\n * Class MenuActiveModifier\n */\nclass MenuActiveModifier implements MenuModifierInterface\n{\n    /**\n     * Modifier the menu node\n     *\n     * @param NodeInterface $menuNode Menu node\n     */\n    public function modify(NodeInterface $menuNode)\n    {\n        $request = ...; // Request\n\n        $currentRoute = $request- get('_route');\n\n        if (in_array($currentRoute, $menuNode- getActiveUrls())) {\n            $menuNode- setActive(true);\n        }\n    }\n}  Then you must add this changer once your manager is instanced in order to use it\nin Menu building time.  use Elcodi\\Component\\Menu\\Services\\MenuModifier;\n\n$menuModifier = new MenuModifier();\n$menuModifier\n    - addMenuModifier(\n        new MenuActiveModifier(),\n        [],\n        ElcodiMenuStages::BEFORE_CACHE,\n        0\n    );\n\n$menuManager = new MenuManager(\n    $menuRepository,\n    $menuObjectManager,\n    $menuCacheKey\n);\n$menuManager\n    - setCache($menuCache)\n    - setEncoder($menuEncoder)\n    - addMenuChanger($menuModifier)\n\n$adminMenu = $menuManager- loadMenuByCode('admin');", 
            "title": "Modifying menus"
        }, 
        {
            "location": "/components/state-transition-machine/", 
            "text": "State Transition Machine\n\n\nAdd states in your entities.\n\n\n\n\nBundle Documentation\n\n\nGithub Repository\n\n\n\n\nCan your entity change its states? This component will help you to implement \nthis in a very decoupled way, providing you a very simple way for definition of\nthese states and a very easy way of managing them.\n\n\nUsage\n\n\nThis component provides you a State Transition Machine for your entities. To\nunderstand what is a State Transition Machine, let's see an example about a use\ncase.\n\n\nLet's figure out we are working with a Order object. We want to give some states\nto this Order, like \"new\", \"paid\" and \"shipped\". Well, this is the perfect\nscenario for this component. The only thing you must define is the set of states\nand how you should jump from one to another.\n\n\nLet's see an example.\n\n\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n\n\n\nYou have four states here.\n\n new: First state or point of entry\n\n paid: The order is paid\n\n shipped: The order is shipped but is not received yet\n\n received: The order is received\n\n\nAnd we have three transitions between these states.\n\n pay: We pay an order\n\n ship: We ship an order\n* receive: A ship is being received\n\n\nMachine Builder\n\n\nSo, this component provides a way to play with all this information in a very\nsingle way, providing as well one machine for each configuration, identified by\na string. Let's see an example of how to build a useful Machine for our project.\n\n\n?php\n\nuse Elcodi\\Component\\StateTransitionMachine\\Factory\\MachineFactor;\n\n$machineIdentifier = 'order_states';\n$pointOfEntry = 'new';\n$machineFactory = new MachineFactory;\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n$machineBuilder = new MachineBuilder(\n    $machineFactory,\n    $machineIdentifier,\n    $configuration,\n    $pointOfEntry\n);\n$machine = $machineBuilder-\ncompile();\n\n\n\n\nTo build a MachineCompiler we need this information:\n\n Machine Factory: The factory that the MachineBuilder will use to build a new\nMachine instance\n\n Machine identifier: The identifier of the machine. This value must be unique\n\n Configuration: The states definition. This parameter must be an array of\nedges, and each edge must be an array with this elements: \nfrom state\n,\n\ntransition name\n and \nto state\n.\n\n Point of Entry: The first state to add once the object is initialized\n\n\nMachine\n\n\nOnce the MachineBuilder is compiled, this method returns us a MachineInterface\nimplementation, with the possibility of using 4 methods.\n\n\n    /**\n     * Get machine id\n     *\n     * @return string Machine identifier\n     */\n    public function getId();\n\n    /**\n     * Get point of entry\n     *\n     * @return string Point of entry\n     */\n    public function getPointOfEntry();\n\n    /**\n     * Applies a transition from a state\n     *\n     * @param string $startStateName Start state name\n     * @param string $transitionName Transition name\n     *\n     * @return Transition Transition created\n     *\n     * @throws TransitionNotAccessibleException Transition not accessible\n     * @throws TransitionNotValidException      Invalid transition name\n     */\n    public function transition(\n        $startStateName,\n        $transitionName\n    );\n\n    /**\n     * Reaches a state given a start state\n     *\n     * @param string $startStateName Start state name\n     * @param string $finalStateName Final state name\n     *\n     * @return Transition Transition created\n     *\n     * @throws StateNotReachableException State is not reachable\n     */\n    public function reachState(\n        $startStateName,\n        $finalStateName\n    );\n\n\n\n\nGiven the last example with the last configuration, lets try to do apply the\n\npay\n transition from the \nnew\n state using the \ntransition\n method.\n\n\necho $machine-\ngetId();\n// = order_states\n\necho $machine-\ngetPointOfEntry();\n// = new\n\n$transition = $machine-\ntransition('unpaid', 'pay');\necho get_class($transition);\n// = \\Elcodi\\Component\\StateTransitionMachine\\Definition\\Transition\n\necho $transition-\ngetName();\n// = pay\n\necho $transition-\ngetStart()-\ngetName();\n// = new\n\necho $transition-\ngetFinal()-\ngetName();\n// = paid\n\n\n\n\nWe can use the \nreachState\n method as well, to reach an specific state no matter\nthe name of the transition. The result should be the same as the last example.\n\n\n$transition = $machine-\nreachState('new', 'paid');\n\n\n\n\nBecause using a machine is a transactional action, all errors will be notified\nwith Exceptions. In that case, because we can not \nship\n an \nnew\n order, we\nwould receive a \nTransitionNotAccessibleException\n exception.\n\n\n$transition = $machine-\ntransition('new', 'ship');\n\n\n\n\nMachineManager\n\n\nTo make things easier and to provide a nice interface for the final user, a\n\nMachineManager\n object is created. This object provide as well a nice interface\nto dispatch events using the Symfony Event Dispatcher Component.\n\n\nLet's see how it works using the previous Machine object. To make it happen, we\nmust work with implementations of the interface\n\n\\Elcodi\\Component\\StateTransitionMachine\\Entity\\Interfaces\\StatefulInterface\n,\nso our \nOrder\n instance is one of these.\n\n\nEvery entity implementing this interface, in order to be able to work with an\nspecific machine, must be initialized once to make sure that the first state is\nalready injected. Once this object is initialized, this action is not required\nanymore.\n\n\n$stateLineFactory = new StateLineFactory();\n$eventDispatcher = new EventDispatcher();\n$machineManager = new MachineManager(\n    $machine,\n    $eventDispatcher,\n    $stateLineFactory,\n);\n\n$order = new Order();\n$machineManager-\ninitialize($order, 'First state');\n$transition = $machineManager-\nreachState($order, 'paid', 'The order have been\npaid');\n\n\n\n\nBecause the point of entry state is \nnew\n and we can reach the State \npaid\n,\nthis transition will be valid.\nIn this action, several events will be dispatched from the $eventDispatched\ninstance.\n\n\nEvents\n\n\n\n\nInitialization:\n\n\nAn object has been initialized in a specific Machine.\n\n\nThe event name is \nstate_machine.{machine_id}.initialization\n, overriding\nthe \n{machine_id}\n with the machine identifier\nDispatches a \n\\Elcodi\\Component\\StateTransitionMachine\\Event\\InitializationEvent\n\nevent.\n\n\n\n\n\n\nTransition from a state:\n\n\nAn object have had a transition from a state.\n\n\nThe event name is \nstate_machine.{machine_id}.transition_from_{state_name}\n,\noverriding \n{machine_id}\n with the machine identifier and \n{state_name}\n\nwith the state name\n\n\nDispatches a \n\\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent\n\nevent.\n\n\n\n\n\n\nTransition:\n\n\nAn object have had a transition.\nThe event name is \nstate_machine.{machine_id}.{transition_name}\n, overriding\n\n{machine_id}\n with the machine identifier and \n{transition_name}\n with\nthe transition name\n\n\nDispatches a \n\\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent\n\nevent.\n\n\n\n\n\n\nTransition to a state:\n\n\nAn object have had a transition to a state.\n\n\nThe event name is \nstate_machine.{machine_id}.transition_to_{state_name}\n,\noverriding \n{machine_id}\n with the machine identifier and \n{state_name}\n\nwith the state name\n\n\nDispatches a \n\\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent\n\nevent.\n\n\n\n\n\n\n\n\nStateTransitionMachine Bundle", 
            "title": "State transition machine"
        }, 
        {
            "location": "/components/state-transition-machine/#state-transition-machine", 
            "text": "Add states in your entities.   Bundle Documentation  Github Repository   Can your entity change its states? This component will help you to implement \nthis in a very decoupled way, providing you a very simple way for definition of\nthese states and a very easy way of managing them.", 
            "title": "State Transition Machine"
        }, 
        {
            "location": "/components/state-transition-machine/#usage", 
            "text": "This component provides you a State Transition Machine for your entities. To\nunderstand what is a State Transition Machine, let's see an example about a use\ncase.  Let's figure out we are working with a Order object. We want to give some states\nto this Order, like \"new\", \"paid\" and \"shipped\". Well, this is the perfect\nscenario for this component. The only thing you must define is the set of states\nand how you should jump from one to another.  Let's see an example.  $configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];  You have four states here.  new: First state or point of entry  paid: The order is paid  shipped: The order is shipped but is not received yet  received: The order is received  And we have three transitions between these states.  pay: We pay an order  ship: We ship an order\n* receive: A ship is being received  Machine Builder  So, this component provides a way to play with all this information in a very\nsingle way, providing as well one machine for each configuration, identified by\na string. Let's see an example of how to build a useful Machine for our project.  ?php\n\nuse Elcodi\\Component\\StateTransitionMachine\\Factory\\MachineFactor;\n\n$machineIdentifier = 'order_states';\n$pointOfEntry = 'new';\n$machineFactory = new MachineFactory;\n$configuration = [\n    'new', 'pay', 'paid',\n    'paid', 'ship', 'shipped',\n    'shipped', 'receive', 'received',\n];\n\n$machineBuilder = new MachineBuilder(\n    $machineFactory,\n    $machineIdentifier,\n    $configuration,\n    $pointOfEntry\n);\n$machine = $machineBuilder- compile();  To build a MachineCompiler we need this information:  Machine Factory: The factory that the MachineBuilder will use to build a new\nMachine instance  Machine identifier: The identifier of the machine. This value must be unique  Configuration: The states definition. This parameter must be an array of\nedges, and each edge must be an array with this elements:  from state , transition name  and  to state .  Point of Entry: The first state to add once the object is initialized  Machine  Once the MachineBuilder is compiled, this method returns us a MachineInterface\nimplementation, with the possibility of using 4 methods.      /**\n     * Get machine id\n     *\n     * @return string Machine identifier\n     */\n    public function getId();\n\n    /**\n     * Get point of entry\n     *\n     * @return string Point of entry\n     */\n    public function getPointOfEntry();\n\n    /**\n     * Applies a transition from a state\n     *\n     * @param string $startStateName Start state name\n     * @param string $transitionName Transition name\n     *\n     * @return Transition Transition created\n     *\n     * @throws TransitionNotAccessibleException Transition not accessible\n     * @throws TransitionNotValidException      Invalid transition name\n     */\n    public function transition(\n        $startStateName,\n        $transitionName\n    );\n\n    /**\n     * Reaches a state given a start state\n     *\n     * @param string $startStateName Start state name\n     * @param string $finalStateName Final state name\n     *\n     * @return Transition Transition created\n     *\n     * @throws StateNotReachableException State is not reachable\n     */\n    public function reachState(\n        $startStateName,\n        $finalStateName\n    );  Given the last example with the last configuration, lets try to do apply the pay  transition from the  new  state using the  transition  method.  echo $machine- getId();\n// = order_states\n\necho $machine- getPointOfEntry();\n// = new\n\n$transition = $machine- transition('unpaid', 'pay');\necho get_class($transition);\n// = \\Elcodi\\Component\\StateTransitionMachine\\Definition\\Transition\n\necho $transition- getName();\n// = pay\n\necho $transition- getStart()- getName();\n// = new\n\necho $transition- getFinal()- getName();\n// = paid  We can use the  reachState  method as well, to reach an specific state no matter\nthe name of the transition. The result should be the same as the last example.  $transition = $machine- reachState('new', 'paid');  Because using a machine is a transactional action, all errors will be notified\nwith Exceptions. In that case, because we can not  ship  an  new  order, we\nwould receive a  TransitionNotAccessibleException  exception.  $transition = $machine- transition('new', 'ship');  MachineManager  To make things easier and to provide a nice interface for the final user, a MachineManager  object is created. This object provide as well a nice interface\nto dispatch events using the Symfony Event Dispatcher Component.  Let's see how it works using the previous Machine object. To make it happen, we\nmust work with implementations of the interface \\Elcodi\\Component\\StateTransitionMachine\\Entity\\Interfaces\\StatefulInterface ,\nso our  Order  instance is one of these.  Every entity implementing this interface, in order to be able to work with an\nspecific machine, must be initialized once to make sure that the first state is\nalready injected. Once this object is initialized, this action is not required\nanymore.  $stateLineFactory = new StateLineFactory();\n$eventDispatcher = new EventDispatcher();\n$machineManager = new MachineManager(\n    $machine,\n    $eventDispatcher,\n    $stateLineFactory,\n);\n\n$order = new Order();\n$machineManager- initialize($order, 'First state');\n$transition = $machineManager- reachState($order, 'paid', 'The order have been\npaid');  Because the point of entry state is  new  and we can reach the State  paid ,\nthis transition will be valid.\nIn this action, several events will be dispatched from the $eventDispatched\ninstance.  Events   Initialization:  An object has been initialized in a specific Machine.  The event name is  state_machine.{machine_id}.initialization , overriding\nthe  {machine_id}  with the machine identifier\nDispatches a  \\Elcodi\\Component\\StateTransitionMachine\\Event\\InitializationEvent \nevent.    Transition from a state:  An object have had a transition from a state.  The event name is  state_machine.{machine_id}.transition_from_{state_name} ,\noverriding  {machine_id}  with the machine identifier and  {state_name} \nwith the state name  Dispatches a  \\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent \nevent.    Transition:  An object have had a transition.\nThe event name is  state_machine.{machine_id}.{transition_name} , overriding {machine_id}  with the machine identifier and  {transition_name}  with\nthe transition name  Dispatches a  \\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent \nevent.    Transition to a state:  An object have had a transition to a state.  The event name is  state_machine.{machine_id}.transition_to_{state_name} ,\noverriding  {machine_id}  with the machine identifier and  {state_name} \nwith the state name  Dispatches a  \\Elcodi\\Component\\StateTransitionMachine\\Event\\TransitionEvent \nevent.", 
            "title": "Usage"
        }, 
        {
            "location": "/components/state-transition-machine/#statetransitionmachine-bundle", 
            "text": "", 
            "title": "StateTransitionMachine Bundle"
        }, 
        {
            "location": "/bundles/attribute/", 
            "text": "Attribute\n\n\nUse and configure the Attribute component in your Symfony project.\n\n\n\n\nComponent Documentation\n\n\nGithub Repository\n\n\n\n\nUsage\n\n\nBecause the extension of the bundle addresses mainly the mapping of the\ntwo main entities Attribute and Value, then there is little to say here.\nHowever, the extension configures automatically directors, factories,\nrepositories, and managers to do the heavy lifting.\n\n\nAttributes as described in the documentation for the component address\nthe need for configurable distinguishable properties for a product.\nYou could ideally describe any product in terms of attributes, e.g.:\n\n\nShoes\n\n    attribute: size\n    values: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n    attribute: material\n    values: [leather, plastic, exotic]\n\n    attribute: technology\n    values: [airFoam, advanceFoam, everlastGrip]\n\n    attribute: manufacturer\n    values: [Japan, Peru, USA, Spain]\n\n    attribute: generation\n    values: [first, second]\n\n    attribute: year\n    values: [2014, 2015, 2016]\n\n    attribute: section\n    values: [mall, smaller shop, airport, complex]\n\n\n\n\nThis is just a representation of how one can describe the product via\nattributes. And it shows really that the attributes are more powerful\nthan to just use them to do selects on product pages. Attributes can\nbe used on the backend more powerfully, have family of attributes that\ncan apply to specific product families or variations. Attribute validation\nis one of the key ideas for configurable products for instance.\n\n\nThe bundle and component lay the foundation only of what is possible.\nAll other things will go in your application.", 
            "title": "Attribute"
        }, 
        {
            "location": "/bundles/attribute/#attribute", 
            "text": "Use and configure the Attribute component in your Symfony project.   Component Documentation  Github Repository", 
            "title": "Attribute"
        }, 
        {
            "location": "/bundles/attribute/#usage", 
            "text": "Because the extension of the bundle addresses mainly the mapping of the\ntwo main entities Attribute and Value, then there is little to say here.\nHowever, the extension configures automatically directors, factories,\nrepositories, and managers to do the heavy lifting.  Attributes as described in the documentation for the component address\nthe need for configurable distinguishable properties for a product.\nYou could ideally describe any product in terms of attributes, e.g.:  Shoes\n\n    attribute: size\n    values: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\n    attribute: material\n    values: [leather, plastic, exotic]\n\n    attribute: technology\n    values: [airFoam, advanceFoam, everlastGrip]\n\n    attribute: manufacturer\n    values: [Japan, Peru, USA, Spain]\n\n    attribute: generation\n    values: [first, second]\n\n    attribute: year\n    values: [2014, 2015, 2016]\n\n    attribute: section\n    values: [mall, smaller shop, airport, complex]  This is just a representation of how one can describe the product via\nattributes. And it shows really that the attributes are more powerful\nthan to just use them to do selects on product pages. Attributes can\nbe used on the backend more powerfully, have family of attributes that\ncan apply to specific product families or variations. Attribute validation\nis one of the key ideas for configurable products for instance.  The bundle and component lay the foundation only of what is possible.\nAll other things will go in your application.", 
            "title": "Usage"
        }, 
        {
            "location": "/bundles/entity-translator/", 
            "text": "Entity Translator\n\n\nUse and configure the EntityTranslator component in your Symfony project.\n\n\n\n\nComponent Documentation\n\n\nGithub Repository\n\n\n\n\nFor that, this implementation hides all the translation model behind a soft\nlayer, so your business model is never modified because of the translation\nneeds.\n\n\nAbout your model\n\n\nEasy and simple. Let's work with a simple entity mapped in Doctrine.\n\n\n/**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type=\nstring\n)\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type=\ntext\n)\n     *\n     * Description\n     */\n    protected $description;\n}\n\n\n\n\nThis example will assume that you want to make both fields, name and\ndescription, translatable. To make it happen, we can simply remove  the mapping\nof both fields, to rely the responsibility of translation to the Translator\ncomponent.\n\n\n/**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n}\n\n\n\n\nNow your installation will see the Product as a simple id. Why is this good for\nus? This example uses Annotations, and we highly recommend to define all your\nmapping configuration using \nyml\n so you can easily decouple your model\nimplementation (entities) and your mapping configuration (Product.orm.yml) and\ndisable some fields for mapping with the same entity implementation.\n\n\nConfiguring the entity translator\n\n\nNow, we need to configure the translator. You need to define what entities and\nfields you allow the engine to manage. Let's see the configuration for this\nexample.\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n\n            // idGetter, by default, getId\n            idGetter: getId\n            fields:\n                name:\n                    // getter, by default, getName in this case\n                    // setter, by default, setName in this case\n                    getter: getName\n                    setter: setName\n                description:\n                    getter: getDescription\n                    setter: setDescription\n\n\n\n\nThis is the basic definition of the Product translation. You can see that there\nis come specific information set by default, so indeed, this configuration could\nbe defined as well that way\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n            fields:\n                name: ~\n                description: ~\n\n\n\n\nYou can use Interfaces as well, so in that case, to ensure that the\nconfiguration will be still valid even if you change the Product implementation,\nyou can use an Interface for that\n\n\nelcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Interfaces\\ProductInterface:\n            alias: product\n            fields:\n                name: ~\n                description: ~\n\n\n\n\nSaving translations\n\n\nDo you want to translate an entity? Great, let's do that! You can easily manage\nyour translation using the entity translator service.\n\n\n$entityTranslator = $this\n    -\ncontainer\n    -\nget('elcodi.entity_translator');\n\n\n\n\nOnce you have the service instance, you can set your entity translations in a\nvery simple way. In this example, let's create a new entity, let's save it into\ndatabase and let's translate it.\n\n\n$product = new Product();\n$product-\nsetId(1);\n\n$entityTranslator-\nsave($product, [\n    'es' =\n [\n        'name' =\n 'el nombre',\n        'description' =\n 'la descripci\u00f3n',\n    ],\n    'en' =\n [\n        'name' =\n 'the name',\n        'description' =\n 'the description',\n        'anotherfield' =\n 'some value',\n    ],\n]);\n\n\n\n\nTranslating an entity\n\n\nSo, your entity is translated? Well, let's load the translations of an entity.\nYou only need the entity and the language you want it to be translated to.\n\n\n$product = $this\n    -\nget('doctrine.orm.entity_manager')\n    -\nfind(1);\n\n$entityTranslator-\ntranslate($product, 'en');\n\n\n\n\nAnd that's it. Your product is now translated to english, and because both\nfields, name and description, are not mapped anymore, you could flush the entity\nmanager and no information would be saved.\n\n\nTranslations in forms\n\n\nThis is maybe the most important feature of this Bundle. How can we handle all\nthis stuff in our forms? Very simple. We don't have to change our form\ndefinition but only adapt it to add an EventSubscriber.\n\n\nLet's see an example.\n\n\nuse Elcodi\\Component\\EntityTranslator\\EventListener\\Traits\\EntityTranslatableFormTrait;\nuse Symfony\\Component\\Form\\AbstractType;\n\n/**\n * Class ProductType\n */\nclass ProductType extends AbstractType\n{\n    use EntityTranslatableFormTrait;\n\n    /**\n     * Buildform function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            -\nadd('name', 'text', [\n                'required' =\n true,\n                'label'    =\n 'name',\n            ])\n            -\nadd('description', 'textarea', [\n                'required' =\n false,\n                'label'    =\n 'description',\n            ]);\n\n        $builder-\naddEventSubscriber($this-\ngetEntityTranslatorFormEventListener());\n    }\n\n    /**\n     * Return unique name for this form\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return 'form_type_product';\n    }\n}\n\n\n\n\nAs you can see, there are only two changes in this formType. First one is that\nyou must add this trait in order to add a protected variable and two methods.\nThe second change is that you must add the EventSubscriber the way is shown in\nthe example.\n\n\nBecause now the formType has some dependencies, you must define this formType as\na service in the dependency injection configuration.\n\n\nservices:\n    form_type.product:\n        class: My\\Namespace\\Form\\Type\\ProductType\n        calls:\n            - [setEntityTranslatorFormEventListener, [@elcodi.entity_translator_form_event_listener]]\n        tags:\n            - { name: form.type, alias: form_type_product }\n\n\n\n\nAnd that's it. Try to render your form, treating name and description like they\nwere normal fields and what you will see is that, instead of rendering a text\ninput field and a Textarea, three of each will be rendered.\n\n\nCustom form views\n\n\nYou can easily customize the way of rendering these fields by adding some format\ninto the rendering of \ntranslatable_field\n. You can find more information in\nchapter - \nWhat are Form Themes?\n\n\nAutomatic entity translation\n\n\nYou can enable the automatic translation of all loaded entities by enabling the\nrelated configuration flag \nauto_translate\n.\n\n\nelcodi_entity_translation:\n    auto_translate: true\n\n\n\n\nBy default this value is true. If true, every time you load a new entity from\nDoctrine than is defined as translatable (a field is included in the\nconfiguration), that entity will be translated using the current locale.", 
            "title": "Entity translator"
        }, 
        {
            "location": "/bundles/entity-translator/#entity-translator", 
            "text": "Use and configure the EntityTranslator component in your Symfony project.   Component Documentation  Github Repository   For that, this implementation hides all the translation model behind a soft\nlayer, so your business model is never modified because of the translation\nneeds.", 
            "title": "Entity Translator"
        }, 
        {
            "location": "/bundles/entity-translator/#about-your-model", 
            "text": "Easy and simple. Let's work with a simple entity mapped in Doctrine.  /**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type= string )\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * @ORM\\Column(type= text )\n     *\n     * Description\n     */\n    protected $description;\n}  This example will assume that you want to make both fields, name and\ndescription, translatable. To make it happen, we can simply remove  the mapping\nof both fields, to rely the responsibility of translation to the Translator\ncomponent.  /**\n * Class Product\n *\n * @ORM\\Entity\n */\nclass Product\n{\n    /**\n     * @var string\n     *\n     * @ORM\\Id\n     * @ORM\\Column\n     * @ORM\\GeneratedValue\n     *\n     * id\n     */\n    protected $id;\n\n    /**\n     * @var string\n     *\n     * Name\n     */\n    protected $name;\n\n    /**\n     * @var string\n     *\n     * Description\n     */\n    protected $description;\n}  Now your installation will see the Product as a simple id. Why is this good for\nus? This example uses Annotations, and we highly recommend to define all your\nmapping configuration using  yml  so you can easily decouple your model\nimplementation (entities) and your mapping configuration (Product.orm.yml) and\ndisable some fields for mapping with the same entity implementation.", 
            "title": "About your model"
        }, 
        {
            "location": "/bundles/entity-translator/#configuring-the-entity-translator", 
            "text": "Now, we need to configure the translator. You need to define what entities and\nfields you allow the engine to manage. Let's see the configuration for this\nexample.  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n\n            // idGetter, by default, getId\n            idGetter: getId\n            fields:\n                name:\n                    // getter, by default, getName in this case\n                    // setter, by default, setName in this case\n                    getter: getName\n                    setter: setName\n                description:\n                    getter: getDescription\n                    setter: setDescription  This is the basic definition of the Product translation. You can see that there\nis come specific information set by default, so indeed, this configuration could\nbe defined as well that way  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Product:\n            alias: product\n            fields:\n                name: ~\n                description: ~  You can use Interfaces as well, so in that case, to ensure that the\nconfiguration will be still valid even if you change the Product implementation,\nyou can use an Interface for that  elcodi_entity_translator:\n    configuration:\n        My\\Bundle\\Entity\\Interfaces\\ProductInterface:\n            alias: product\n            fields:\n                name: ~\n                description: ~", 
            "title": "Configuring the entity translator"
        }, 
        {
            "location": "/bundles/entity-translator/#saving-translations", 
            "text": "Do you want to translate an entity? Great, let's do that! You can easily manage\nyour translation using the entity translator service.  $entityTranslator = $this\n    - container\n    - get('elcodi.entity_translator');  Once you have the service instance, you can set your entity translations in a\nvery simple way. In this example, let's create a new entity, let's save it into\ndatabase and let's translate it.  $product = new Product();\n$product- setId(1);\n\n$entityTranslator- save($product, [\n    'es' =  [\n        'name' =  'el nombre',\n        'description' =  'la descripci\u00f3n',\n    ],\n    'en' =  [\n        'name' =  'the name',\n        'description' =  'the description',\n        'anotherfield' =  'some value',\n    ],\n]);", 
            "title": "Saving translations"
        }, 
        {
            "location": "/bundles/entity-translator/#translating-an-entity", 
            "text": "So, your entity is translated? Well, let's load the translations of an entity.\nYou only need the entity and the language you want it to be translated to.  $product = $this\n    - get('doctrine.orm.entity_manager')\n    - find(1);\n\n$entityTranslator- translate($product, 'en');  And that's it. Your product is now translated to english, and because both\nfields, name and description, are not mapped anymore, you could flush the entity\nmanager and no information would be saved.", 
            "title": "Translating an entity"
        }, 
        {
            "location": "/bundles/entity-translator/#translations-in-forms", 
            "text": "This is maybe the most important feature of this Bundle. How can we handle all\nthis stuff in our forms? Very simple. We don't have to change our form\ndefinition but only adapt it to add an EventSubscriber.  Let's see an example.  use Elcodi\\Component\\EntityTranslator\\EventListener\\Traits\\EntityTranslatableFormTrait;\nuse Symfony\\Component\\Form\\AbstractType;\n\n/**\n * Class ProductType\n */\nclass ProductType extends AbstractType\n{\n    use EntityTranslatableFormTrait;\n\n    /**\n     * Buildform function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            - add('name', 'text', [\n                'required' =  true,\n                'label'    =  'name',\n            ])\n            - add('description', 'textarea', [\n                'required' =  false,\n                'label'    =  'description',\n            ]);\n\n        $builder- addEventSubscriber($this- getEntityTranslatorFormEventListener());\n    }\n\n    /**\n     * Return unique name for this form\n     *\n     * @return string\n     */\n    public function getName()\n    {\n        return 'form_type_product';\n    }\n}  As you can see, there are only two changes in this formType. First one is that\nyou must add this trait in order to add a protected variable and two methods.\nThe second change is that you must add the EventSubscriber the way is shown in\nthe example.  Because now the formType has some dependencies, you must define this formType as\na service in the dependency injection configuration.  services:\n    form_type.product:\n        class: My\\Namespace\\Form\\Type\\ProductType\n        calls:\n            - [setEntityTranslatorFormEventListener, [@elcodi.entity_translator_form_event_listener]]\n        tags:\n            - { name: form.type, alias: form_type_product }  And that's it. Try to render your form, treating name and description like they\nwere normal fields and what you will see is that, instead of rendering a text\ninput field and a Textarea, three of each will be rendered.", 
            "title": "Translations in forms"
        }, 
        {
            "location": "/bundles/entity-translator/#custom-form-views", 
            "text": "You can easily customize the way of rendering these fields by adding some format\ninto the rendering of  translatable_field . You can find more information in\nchapter -  What are Form Themes?", 
            "title": "Custom form views"
        }, 
        {
            "location": "/bundles/entity-translator/#automatic-entity-translation", 
            "text": "You can enable the automatic translation of all loaded entities by enabling the\nrelated configuration flag  auto_translate .  elcodi_entity_translation:\n    auto_translate: true  By default this value is true. If true, every time you load a new entity from\nDoctrine than is defined as translatable (a field is included in the\nconfiguration), that entity will be translated using the current locale.", 
            "title": "Automatic entity translation"
        }, 
        {
            "location": "/bundles/", 
            "text": "The Bundles\n\n\n\n\nAttribute\n\n\nSitemap\n\n\nEntity Translator\n\n\nMenu", 
            "title": "Home"
        }, 
        {
            "location": "/bundles/#the-bundles", 
            "text": "Attribute  Sitemap  Entity Translator  Menu", 
            "title": "The Bundles"
        }, 
        {
            "location": "/bundles/menu/", 
            "text": "Menu\n\n\nUse and configure the Menu component in your Symfony project.\n\n\n\n\nComponent Documentation\n\n\nGithub Repository\n\n\n\n\nUsing the DIC\n\n\nExposing your Menu changers (Filters, Builders and Modifiers) is so simple using\nthe Symfony Dependency Injection definitions. For this purpose, this bundle is\nbuilt on top the tags feature, allowing to define a simple changer just adding\na simple tag.\n\n\nBy default, this Bundle has three changers defined and enabled.\n\n\nservices:\n\n    #\n    # Menu filters\n    #\n    elcodi.menu_filter.menu_disabled:\n        class: Elcodi\\Component\\Menu\\Filter\\MenuDisabledFilter\n        tags:\n            - { name: menu.filter }\n\n    #\n    # Menu modifiers\n    #\n    elcodi.menu_modifier.menu_active:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuActiveModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n    elcodi.menu_modifier.menu_expanded:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuExpandedModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n\n\n\nAs you can see, there is no any Builder defined here. Let's see an example of a\nBuilder definition.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.plugins:\n        class: Elcodi\\Admin\\PluginBundle\\MenuBuilder\\PluginMenuBuilder\n        arguments:\n            - @elcodi.factory.menu_node\n            - @router\n            - @elcodi.enabled_plugins\n        tags:\n            - { name: menu.builder }\n\n\n\n\nYou can define as much elements you need.\n\n\nWorkflow\n\n\nThe order matters. It means that is not the same to apply all the filters first\nof all and then execute the modifiers, or applying the other way.\n\n\nThis bundle define all changers in this order\n\n\n\n\nBuilders\n\n\nFilters\n\n\nModifiers\n\n\n\n\nCache\n\n\nEach changer can be used before or after cache by setting its stage. Please, \nread the \ncomponent documentation\n to \nunderstand what means this configuration and what is indended for.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, stage: before_cache }\n            - { name: menu.builder, stage: after_cache }\n\n\n\n\nBy default, \nbefore_cache\n will be used.\n\n\nSpecific menus\n\n\nEach changer can be assigned to a set of menus by using the menus property in \nthe tag definition.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, menus: ['admin', 'store'] }\n\n\n\n\nBy default, all menus will be assigned.\n\n\nPriority\n\n\nEach group will prioritize all its instances by using priority. You can set a \npriority using the tag.\n\n\nservices:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, priority: 10 }\n\n\n\n\nBy default, priority 0 will be used.\n\n\n\n\nThe more priority, the before this changer is applied. Negative values are\nkindly allowed here.", 
            "title": "Menu"
        }, 
        {
            "location": "/bundles/menu/#menu", 
            "text": "Use and configure the Menu component in your Symfony project.   Component Documentation  Github Repository", 
            "title": "Menu"
        }, 
        {
            "location": "/bundles/menu/#using-the-dic", 
            "text": "Exposing your Menu changers (Filters, Builders and Modifiers) is so simple using\nthe Symfony Dependency Injection definitions. For this purpose, this bundle is\nbuilt on top the tags feature, allowing to define a simple changer just adding\na simple tag.  By default, this Bundle has three changers defined and enabled.  services:\n\n    #\n    # Menu filters\n    #\n    elcodi.menu_filter.menu_disabled:\n        class: Elcodi\\Component\\Menu\\Filter\\MenuDisabledFilter\n        tags:\n            - { name: menu.filter }\n\n    #\n    # Menu modifiers\n    #\n    elcodi.menu_modifier.menu_active:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuActiveModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }\n\n    elcodi.menu_modifier.menu_expanded:\n        class: Elcodi\\Component\\Menu\\Modifier\\MenuExpandedModifier\n        arguments:\n            - @request_stack\n        tags:\n            - { name: menu.modifier }  As you can see, there is no any Builder defined here. Let's see an example of a\nBuilder definition.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.plugins:\n        class: Elcodi\\Admin\\PluginBundle\\MenuBuilder\\PluginMenuBuilder\n        arguments:\n            - @elcodi.factory.menu_node\n            - @router\n            - @elcodi.enabled_plugins\n        tags:\n            - { name: menu.builder }  You can define as much elements you need.", 
            "title": "Using the DIC"
        }, 
        {
            "location": "/bundles/menu/#workflow", 
            "text": "The order matters. It means that is not the same to apply all the filters first\nof all and then execute the modifiers, or applying the other way.  This bundle define all changers in this order   Builders  Filters  Modifiers", 
            "title": "Workflow"
        }, 
        {
            "location": "/bundles/menu/#cache", 
            "text": "Each changer can be used before or after cache by setting its stage. Please, \nread the  component documentation  to \nunderstand what means this configuration and what is indended for.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, stage: before_cache }\n            - { name: menu.builder, stage: after_cache }  By default,  before_cache  will be used.", 
            "title": "Cache"
        }, 
        {
            "location": "/bundles/menu/#specific-menus", 
            "text": "Each changer can be assigned to a set of menus by using the menus property in \nthe tag definition.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, menus: ['admin', 'store'] }  By default, all menus will be assigned.", 
            "title": "Specific menus"
        }, 
        {
            "location": "/bundles/menu/#priority", 
            "text": "Each group will prioritize all its instances by using priority. You can set a \npriority using the tag.  services:\n\n    #\n    # Menu builders\n    #\n    store.plugin.menu_builder.some_builder:\n        class: Namespace\\Of\\Menu\\Builder\n        tags:\n            - { name: menu.builder, priority: 10 }  By default, priority 0 will be used.   The more priority, the before this changer is applied. Negative values are\nkindly allowed here.", 
            "title": "Priority"
        }, 
        {
            "location": "/bundles/sitemap/", 
            "text": "Sitemap\n\n\nUse and configure the Sitemap component in your Symfony project.\n\n\n\n\nComponent Documentation\n\n\nGithub Repository\n\n\n\n\nThe bundle is built in different layers, going from the real seed of any kind\nof sitemap implementation (each element), to the final profiling.\n\n\nBlocks\n\n\nOn a sitemap, a block is the element that we would like to index. If a product\nhas a page then we would like our sitemap to contain an entry url per product \npage. The items to index in a sitemap can be pages of products, categories, and \nany other entity on the project.\n\n\nWhen we talk about a block, we are really talking about a specific set of urls\nrelated to entities provided by a specific repository, for example all enabled \nproducts.\n\n\n# Each block defines a way of creating dynamically a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: ~\n        # Repository service used for retrieving the array of entities\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~\n\n\n\n\nEach block needs a transformer, intended to transform an entity instance to \nevery single information needed by the sitemap generator. Every transformer must\nbe an implementation of SitemapTransformerInterface and must be defined as a\nservice in our Dependency Injection Container.\n\n\n/**\n * Interface SitemapTransformerInterface\n */\ninterface SitemapTransformerInterface\n{\n    /**\n     * Get url given an entity\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string url\n     */\n    public function getLoc($element, $language = null);\n\n    /**\n     * Get last mod\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string Last mod value\n     */\n    public function getLastMod($element, $language = null);\n}\n\n\n\n\nThen we need to pass the name of the service to the block configuration.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: elcodi.sitemap_transformer.product\n\n\n\n\n\n\nThis element is a mandatory and must be defined for each Block\n\n\n\n\nThat said, we need to also define how this product collection must be\nretrieved from our database. For this reason you must specify the\nrepository service, the method used and the arguments for such method.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n            disabled: false\n\n\n\n\nThese elements are required and have no default values, to make sure\nthat every block definition is carefully defined and configured. \n\n\nFinally, we can define the \nchangeFrequency\n and the \npriority\n elements. Both\nvalues will be used for all block instances. They are not required.\n\n\n# Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~\n\n\n\n\nStatics\n\n\nAn Static is a representation of a route, defined by its name and some \nnon-required values.\n\n\nelcodi_sitemap:\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~\n\n\n\n\nBuilders\n\n\nA sitemap instance is built using a sorted set of Statics and Blocks and\nrendered by a specific renderer. The result of this built is dumped using a\nspecific dumper in a pre-defined path.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking into account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n\n\n\nFirst of all we need to define what blocks and statics we are going to use for\nsuch sitemap. It is important to know that the order matters.\n\n\nFor example, in our case, we will create a new sitemap called \nmain\n that will\ncontain a block and a static.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n\n\n\n\n\n\nThis component will first render the statics and then the blocks.\n\n\n\n\nThen, a renderer will transform this set of entries into a special format. By \ndefault this component gives you one renderer implementation, the \nXmlRenderer\n.\nThis implementation is the one used by default.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n\n\n\n\nIf you want to use your own renderer, you can create a new service implementing \n\nSitemapRendererInterface\n.\n\n\n/**\n * Interface SitemapRendererInterface\n */\ninterface SitemapRendererInterface\n{\n    /**\n     * Given an array of sitemapElements, renders the Sitemap\n     *\n     * @param SitemapElement[] $sitemapElements Elements\n     * @param string           $basepath        Base path\n     *\n     * @return string Render\n     */\n    public function render(array $sitemapElements, $basepath);\n}\n\n\n\n\nFinally, a dumper will dump your rendered data. By default this component gives\nyou one dumper implementation, the \nFilesystemDumper\n. This implementation is \nthe one used by default.\n\n\nelcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml\n\n\n\n\nIf you want to use your own dumper, you can create a new dumper implementing\n\nSitemapDumperInterface\n.\n\n\n/**\n * Interface SitemapDumperInterface\n */\ninterface SitemapDumperInterface\n{\n    /**\n     * Dumps a sitemap given a path\n     *\n     * @param string $path    Path\n     * @param string $sitemap Sitemap\n     *\n     * @return $this Self object\n     */\n    public function dump($path, $sitemap);\n}\n\n\n\n\nThis dumper uses a path. This path is required by any defined builder and can\ncontain a placeholder for the sitemap language, using \n{_locale}\n.\n\n\nServices\n\n\nElcodi generates a Dependency Injection service for each builder using our\nstandard. In our example, with given configuration we will have available a new\npublic service.\n\n\nelcodi.sitemap_builder.main\n\n\n\n\nCalling this service, the DI will create a SitemapBuilder instance, ready\nto be used.\n\n\n/**\n * Class SitemapBuilder\n */\nclass SitemapBuilder\n{\n    /**\n     * Build sitemap builder\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     *\n     * @return string Generated data\n     */\n    public function build($basepath, $language = null);\n}\n\n\n\n\nElcodi also generates a service for each dumper, using the same notation as\nbuilders.\n\n\nelcodi.sitemap_dumper.main\n\n\n\n\nCalling this service, the DI will create a SitemapDumper instance, ready\nto be used.\n\n\n/\n\n * Class SitemapDumper\n */\nclass SitemapDumper\n{\n    /\n\n     * Dump builder using a dumper\n     \n\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     \n/\n    public function dump($basepath, $language = null);\n}\n\n\nAs you can see, both services require the basepath of the site. It means that\nyou can call, for example, the \nbuild\n method using firstly the basepath \n\nhttp://localhost:8000\n and then \nhttps://myurl.com\n. Because this information\ndoes not belong to the instance but the call, it is mandatory to set this\ninformation when the sitemap is generated.\n\n\nYou must define the language as well, but this second parameter is not required.\nThis value is passed to the transformer, and your transformer implementation \nwill decide what to do with this language.\n\n\nDumper Command\n\n\nThis command is intended for a single sitemap generation. You must provide the\nname of the builder as each builder has an associated dumper and a specific \nbasepath used for this built and an optional language.\n\n\nphp app/console elcodi:sitemap:dump main http://localhost:8000\nphp app/console elcodi:sitemap:dump main https://myurl.com\nphp app/console elcodi:sitemap:dump main http://localhost:8000 --language=es\n\n\n\n\nProfiles\n\n\nUsing the dumper is so nice and easy if you just manage static languages, but\nhow about if our site needs to generate several builders using, for example, all \nthe enabled languages of our site?\n\n\nIn order to solve this common problem, this bundle provides as well what we call\na sitemap profile.\n\n\nelcodi_sitemap:\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main\n\n\n\n\nThere are two elements to be defined here, both required.\n\n\nFirst, we need to decide what builders we want to include in this profile.\nThis is just a set of builders, an array. That easy.\n\n\nSecond, we must define a service in our project, intended to return all enabled\nlanguages in our site. This service must return an array of locales.\n\n\nIn elcodi we have a service called \nelcodi.languages_iso\n.\n\n\nelcodi.languages_iso_array:\n    class: stdClass\n    factory: [@elcodi.languages_iso, toArray]\n\n\n\n\n\n\nYes, in Symfony a service can use the factory pattern to return a simple \narray using the stdClass keyword.\n\n\n\n\nElcodi generates a service for each profile, using our standard. In our example, \nwith the given configuration we will have available a new public service.\n\n\nelcodi.sitemap_profile.main\n\n\n\n\nCalling this service, the DI will create a SitemapProfile instance, ready\nto be used.\n\n\n/**\n * Class SitemapProfile\n */\nclass SitemapProfile\n{\n    /**\n     * Build full profile\n     *\n     * @param string $basepath Basepath\n     *\n     * @return $this Self object\n     */\n    public function dump($basepath);\n}\n\n\n\n\nProfile Command\n\n\nThis command is intended for profile generation. You must provide the\nname of the profile and a specific basepath used for this build.\n\n\nphp app/console elcodi:sitemap:profile main http://localhost:8000\nphp app/console elcodi:sitemap:profile main https://myurl.com", 
            "title": "Sitemap"
        }, 
        {
            "location": "/bundles/sitemap/#sitemap", 
            "text": "Use and configure the Sitemap component in your Symfony project.   Component Documentation  Github Repository   The bundle is built in different layers, going from the real seed of any kind\nof sitemap implementation (each element), to the final profiling.  Blocks  On a sitemap, a block is the element that we would like to index. If a product\nhas a page then we would like our sitemap to contain an entry url per product \npage. The items to index in a sitemap can be pages of products, categories, and \nany other entity on the project.  When we talk about a block, we are really talking about a specific set of urls\nrelated to entities provided by a specific repository, for example all enabled \nproducts.  # Each block defines a way of creating dynamically a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: ~\n        # Repository service used for retrieving the array of entities\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~  Each block needs a transformer, intended to transform an entity instance to \nevery single information needed by the sitemap generator. Every transformer must\nbe an implementation of SitemapTransformerInterface and must be defined as a\nservice in our Dependency Injection Container.  /**\n * Interface SitemapTransformerInterface\n */\ninterface SitemapTransformerInterface\n{\n    /**\n     * Get url given an entity\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string url\n     */\n    public function getLoc($element, $language = null);\n\n    /**\n     * Get last mod\n     *\n     * @param Mixed  $element  Element\n     * @param string $language Language\n     *\n     * @return string Last mod value\n     */\n    public function getLastMod($element, $language = null);\n}  Then we need to pass the name of the service to the block configuration.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Transformer\n        transformer: elcodi.sitemap_transformer.product   This element is a mandatory and must be defined for each Block   That said, we need to also define how this product collection must be\nretrieved from our database. For this reason you must specify the\nrepository service, the method used and the arguments for such method.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        repository_service: elcodi.repository.product\n        # Repository method\n        method: findBy\n        # Array of arguments for the repository call\n        arguments:\n            enabled: true\n            disabled: false  These elements are required and have no default values, to make sure\nthat every block definition is carefully defined and configured.   Finally, we can define the  changeFrequency  and the  priority  elements. Both\nvalues will be used for all block instances. They are not required.  # Each block defines a way of dynamically creating a set of elements of a\n# sitemap file, each one mapped from a database entry\nblocks:\n    enabled_products:\n        # Specific change frequency for this block\n        changeFrequency: ~\n        # Specific priority for this block\n        priority: ~  Statics  An Static is a representation of a route, defined by its name and some \nnon-required values.  elcodi_sitemap:\n\n    # Each static is a route entry\n    statics:\n        store_homepage:\n            # Specific change frequency for this static\n            changeFrequency: ~\n            # Specific priority for this static\n            priority: ~  Builders  A sitemap instance is built using a sorted set of Statics and Blocks and\nrendered by a specific renderer. The result of this built is dumped using a\nspecific dumper in a pre-defined path.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~\n            # Each builder can use a different dumper, by referencing the\n            # service definition\n            dumper: ~\n            # You can define the name of the file, taking into account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml  First of all we need to define what blocks and statics we are going to use for\nsuch sitemap. It is important to know that the order matters.  For example, in our case, we will create a new sitemap called  main  that will\ncontain a block and a static.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Set of block references\n            blocks:\n                - enabled_products\n            # Set of static references\n            statics:\n                - store_homepage   This component will first render the statics and then the blocks.   Then, a renderer will transform this set of entries into a special format. By \ndefault this component gives you one renderer implementation, the  XmlRenderer .\nThis implementation is the one used by default.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            # Each builder can use a different renderer, by referencing the\n            # service definition\n            renderer: ~  If you want to use your own renderer, you can create a new service implementing  SitemapRendererInterface .  /**\n * Interface SitemapRendererInterface\n */\ninterface SitemapRendererInterface\n{\n    /**\n     * Given an array of sitemapElements, renders the Sitemap\n     *\n     * @param SitemapElement[] $sitemapElements Elements\n     * @param string           $basepath        Base path\n     *\n     * @return string Render\n     */\n    public function render(array $sitemapElements, $basepath);\n}  Finally, a dumper will dump your rendered data. By default this component gives\nyou one dumper implementation, the  FilesystemDumper . This implementation is \nthe one used by default.  elcodi_sitemap:\n\n    # A builder is a set of blocks and statics, grouped and saved to a file\n    builder:\n        main:\n            dumper: ~\n            # You can define the name of the file, taking in account the locale\n            # used by using {_locale} format\n            path: %kernel.root_dir%/../web/sitemap/sitemap_{_locale}.xml  If you want to use your own dumper, you can create a new dumper implementing SitemapDumperInterface .  /**\n * Interface SitemapDumperInterface\n */\ninterface SitemapDumperInterface\n{\n    /**\n     * Dumps a sitemap given a path\n     *\n     * @param string $path    Path\n     * @param string $sitemap Sitemap\n     *\n     * @return $this Self object\n     */\n    public function dump($path, $sitemap);\n}  This dumper uses a path. This path is required by any defined builder and can\ncontain a placeholder for the sitemap language, using  {_locale} .  Services  Elcodi generates a Dependency Injection service for each builder using our\nstandard. In our example, with given configuration we will have available a new\npublic service.  elcodi.sitemap_builder.main  Calling this service, the DI will create a SitemapBuilder instance, ready\nto be used.  /**\n * Class SitemapBuilder\n */\nclass SitemapBuilder\n{\n    /**\n     * Build sitemap builder\n     *\n     * @param string      $basepath Base path\n     * @param string|null $language Language\n     *\n     * @return string Generated data\n     */\n    public function build($basepath, $language = null);\n}  Elcodi also generates a service for each dumper, using the same notation as\nbuilders.  elcodi.sitemap_dumper.main  Calling this service, the DI will create a SitemapDumper instance, ready\nto be used.  / \n * Class SitemapDumper\n */\nclass SitemapDumper\n{\n    / \n     * Dump builder using a dumper\n      \n     * @param string      $basepath Base path\n     * @param string|null $language Language\n      /\n    public function dump($basepath, $language = null);\n}  As you can see, both services require the basepath of the site. It means that\nyou can call, for example, the  build  method using firstly the basepath  http://localhost:8000  and then  https://myurl.com . Because this information\ndoes not belong to the instance but the call, it is mandatory to set this\ninformation when the sitemap is generated.  You must define the language as well, but this second parameter is not required.\nThis value is passed to the transformer, and your transformer implementation \nwill decide what to do with this language.  Dumper Command  This command is intended for a single sitemap generation. You must provide the\nname of the builder as each builder has an associated dumper and a specific \nbasepath used for this built and an optional language.  php app/console elcodi:sitemap:dump main http://localhost:8000\nphp app/console elcodi:sitemap:dump main https://myurl.com\nphp app/console elcodi:sitemap:dump main http://localhost:8000 --language=es  Profiles  Using the dumper is so nice and easy if you just manage static languages, but\nhow about if our site needs to generate several builders using, for example, all \nthe enabled languages of our site?  In order to solve this common problem, this bundle provides as well what we call\na sitemap profile.  elcodi_sitemap:\n\n    # A profile is a set of builders, grouped and combined with all available\n    # languages. Special for bulk actions\n    profile:\n        main:\n            # Service reference, result which is an array of languages\n            languages: elcodi.languages_iso_array\n            # Set of builder references\n            builders:\n                - main  There are two elements to be defined here, both required.  First, we need to decide what builders we want to include in this profile.\nThis is just a set of builders, an array. That easy.  Second, we must define a service in our project, intended to return all enabled\nlanguages in our site. This service must return an array of locales.  In elcodi we have a service called  elcodi.languages_iso .  elcodi.languages_iso_array:\n    class: stdClass\n    factory: [@elcodi.languages_iso, toArray]   Yes, in Symfony a service can use the factory pattern to return a simple \narray using the stdClass keyword.   Elcodi generates a service for each profile, using our standard. In our example, \nwith the given configuration we will have available a new public service.  elcodi.sitemap_profile.main  Calling this service, the DI will create a SitemapProfile instance, ready\nto be used.  /**\n * Class SitemapProfile\n */\nclass SitemapProfile\n{\n    /**\n     * Build full profile\n     *\n     * @param string $basepath Basepath\n     *\n     * @return $this Self object\n     */\n    public function dump($basepath);\n}  Profile Command  This command is intended for profile generation. You must provide the\nname of the profile and a specific basepath used for this build.  php app/console elcodi:sitemap:profile main http://localhost:8000\nphp app/console elcodi:sitemap:profile main https://myurl.com", 
            "title": "Sitemap"
        }, 
        {
            "location": "/book/", 
            "text": "Book\n\n\nPrepared by Elcodi core team and contributors, this is the Elcodi bible. It is the reference for \nany user of the platform, who will typically want to keep it close at hand.\n\n\nTable of contents\n\n\n\n\nElcodi Philosophy\n\n\nDependency Injection Standards\n\n\nClasses Standards\n\n\nCoding Standards\n\n\nPackages Structure\n\n\nBundle Extensions\n\n\nPlugins\n\n\nTemplates\n\n\nUsing the Cart", 
            "title": "Home"
        }, 
        {
            "location": "/book/#book", 
            "text": "Prepared by Elcodi core team and contributors, this is the Elcodi bible. It is the reference for \nany user of the platform, who will typically want to keep it close at hand.  Table of contents   Elcodi Philosophy  Dependency Injection Standards  Classes Standards  Coding Standards  Packages Structure  Bundle Extensions  Plugins  Templates  Using the Cart", 
            "title": "Book"
        }, 
        {
            "location": "/book/standards/classes/", 
            "text": "Classes Standards\n\n\nIn order to create homogeneous code, we've defined a set of rules when creating\nand naming classes.\n\n\nAbstracts\n\n\nMaybe is not the best standard, but we strongly believe that the name of a class\nshould explain its mission as much as possible. Because this\nis an OpenSource project we must take care about all different skilled \ndevelopers so the name of an abstract class, even if it is redundant, will have\nthe word \nAbstract\n at the end of the name.\n\n\nabstract class AbstractFactory\n{\n}\n\n\n\n\nFurthermore, any abstract class will be placed in a folder called \nAbstracts/\n,\nto make them easier to find.\n\n\n\\Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory\n\n\n\n\n\n\nThe namespace must be Abstracts instead of Abstract because Abstract is a PHP\nreserved keyword\n\n\n\n\nTraits\n\n\nSame as Abstract classes. All Traits will have the word \nTrait\n at the end of \nthe name\n\n\ntrait DateTimeTrait\n{\n}\n\n\n\n\nFurthermore, any trait will be placed in a folder called \nTraits/\n, to make them \neasier to find.\n\n\n\\Elcodi\\Component\\Core\\Entity\\Traits\\DateTimeTrait\n\n\n\n\n\n\nThe namespace must be Traits instead of Trait because Trait is a PHP reserved \nkeyword\n\n\n\n\nThere is a limitation in the definition of Traits in PHP, and it is that\nthere is a collision problem of namespaces. Because they are virtually \ncopy/pasted to the final class, you can have some problems if you work with\nnamespaces inside the Trait classes.\n\n\nThe way of solving this is never using use statements in a Trait, and always \nusing all the namespace when referencing a PHP namespace.\n\n\ntrait PriceTrait\n{\n    /**\n     * @var \\Elcodi\\Component\\Currency\\Entity\\Interfaces\\CurrencyInterface\n     *\n     * Currency for the amounts stored in this entity\n     */\n    protected $productCurrency;\n\n\n\n\nInterfaces\n\n\nSame as Abstract classes. All Interfaces will have the word \nInterface\n at the \nend of the name\n\n\ninterface OrderInterface\n{\n}\n\n\n\n\nFurthermore, any interface will be placed in a folder called \nInterfaces/\n, to \nmake them easier to find.\n\n\n\\Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface\n\n\n\n\n\n\nThe namespace must be Interfaces instead of Interface because Interface is a \nPHP reserved keyword\n\n\n\n\nBundles\n\n\nEach Bundle should avoid the magic of auto-discovering, placed in the class\n\nSymfony\\Component\\HttpKernel\\Bundle\\Bundle\n.\n\n\nYes, we're talking about these methods:\n\n\n\n\ngetContainerExtension()\n\n\nregisterCommands()\n\n\n\n\nIn order to forget about magic there, and to clearly define our Bundles, we will\nalways overwrite these methods, returning specifically the data is intended to\nreturn, even if methods are empty.\n\n\nuse Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\ElcodiCoreExtension;\n\n/**\n * ElcodiCoreBundle Bundle\n *\n * This is the core of the suite.\n * All available bundles in this suite could have this bundle as a main\n * dependency.\n */\nclass ElcodiCoreBundle extends Bundle\n{\n    /**\n     * Returns the bundle's container extension.\n     *\n     * @return ExtensionInterface The container extension\n     */\n    public function getContainerExtension()\n    {\n        return new ElcodiCoreExtension();\n    }\n\n    /**\n     * Register Commands.\n     *\n     * Disabled as commands are registered as services\n     *\n     * @param Application $application An Application instance\n     */\n    public function registerCommands(Application $application)\n    {\n        return;\n    }\n}", 
            "title": "Classes"
        }, 
        {
            "location": "/book/standards/classes/#classes-standards", 
            "text": "In order to create homogeneous code, we've defined a set of rules when creating\nand naming classes.  Abstracts  Maybe is not the best standard, but we strongly believe that the name of a class\nshould explain its mission as much as possible. Because this\nis an OpenSource project we must take care about all different skilled \ndevelopers so the name of an abstract class, even if it is redundant, will have\nthe word  Abstract  at the end of the name.  abstract class AbstractFactory\n{\n}  Furthermore, any abstract class will be placed in a folder called  Abstracts/ ,\nto make them easier to find.  \\Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory   The namespace must be Abstracts instead of Abstract because Abstract is a PHP\nreserved keyword   Traits  Same as Abstract classes. All Traits will have the word  Trait  at the end of \nthe name  trait DateTimeTrait\n{\n}  Furthermore, any trait will be placed in a folder called  Traits/ , to make them \neasier to find.  \\Elcodi\\Component\\Core\\Entity\\Traits\\DateTimeTrait   The namespace must be Traits instead of Trait because Trait is a PHP reserved \nkeyword   There is a limitation in the definition of Traits in PHP, and it is that\nthere is a collision problem of namespaces. Because they are virtually \ncopy/pasted to the final class, you can have some problems if you work with\nnamespaces inside the Trait classes.  The way of solving this is never using use statements in a Trait, and always \nusing all the namespace when referencing a PHP namespace.  trait PriceTrait\n{\n    /**\n     * @var \\Elcodi\\Component\\Currency\\Entity\\Interfaces\\CurrencyInterface\n     *\n     * Currency for the amounts stored in this entity\n     */\n    protected $productCurrency;  Interfaces  Same as Abstract classes. All Interfaces will have the word  Interface  at the \nend of the name  interface OrderInterface\n{\n}  Furthermore, any interface will be placed in a folder called  Interfaces/ , to \nmake them easier to find.  \\Elcodi\\Component\\Cart\\Entity\\Interfaces\\OrderInterface   The namespace must be Interfaces instead of Interface because Interface is a \nPHP reserved keyword   Bundles  Each Bundle should avoid the magic of auto-discovering, placed in the class Symfony\\Component\\HttpKernel\\Bundle\\Bundle .  Yes, we're talking about these methods:   getContainerExtension()  registerCommands()   In order to forget about magic there, and to clearly define our Bundles, we will\nalways overwrite these methods, returning specifically the data is intended to\nreturn, even if methods are empty.  use Symfony\\Component\\Console\\Application;\nuse Symfony\\Component\\DependencyInjection\\Extension\\ExtensionInterface;\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\ElcodiCoreExtension;\n\n/**\n * ElcodiCoreBundle Bundle\n *\n * This is the core of the suite.\n * All available bundles in this suite could have this bundle as a main\n * dependency.\n */\nclass ElcodiCoreBundle extends Bundle\n{\n    /**\n     * Returns the bundle's container extension.\n     *\n     * @return ExtensionInterface The container extension\n     */\n    public function getContainerExtension()\n    {\n        return new ElcodiCoreExtension();\n    }\n\n    /**\n     * Register Commands.\n     *\n     * Disabled as commands are registered as services\n     *\n     * @param Application $application An Application instance\n     */\n    public function registerCommands(Application $application)\n    {\n        return;\n    }\n}", 
            "title": "Classes Standards"
        }, 
        {
            "location": "/book/standards/code/", 
            "text": "Coding Standards\n\n\nWe have noticed that everyone has a different way of developing. In our team, \nsome people place the braces at the end of the class definition, while other\npeople place them in a new line.\n\n\nIs anyone wrong? Absolutely not, even PHP has standards since long time\nago, and besides anyone should also be able to work the way they want.\n\n\nBut in Elcodi we have some standards for our code.\n\n\nSmall classes and methods\n\n\nEach class should be small enough to contain specific information. Remember to\nuse small methods (no more than 20 lines) and to take care of their complexity.\nThe more complex a method is, the harder to understand what is all\nabout.\n\n\nPHPDoc\n\n\nThis is an important part of the project.\n\n\nAll methods must be explained for humans. Some people think that the code should\nbe self-explanatory, and we agree on that. This doesn't mean that all people \nshould read the code to understand what a method is intended for.\n\n\nPretending them to understand our method by its code is to prevent them to focus \non their own business logic, and can hinder development speed.\n\n\nAll methods must follow these rules as well, related to PHP Doc format\n\n\n/**\n * This is my detailed description about what my code is intended for\n * I can use as many lines as possible.\n * I repeat, as many lines as possible.\n *\n * @param MyObject $myObject My object description\n * @param string   $info     Some information\n * @param integer  $number   Some number\n *\n * @return Factory Description of the result\n *\n * @throws AnException Scenario when this exception is thrown\n */\n\n\n\n\nUsing this kind of blocks there are some tips we all need to take into account.\n\n\n\n\nThere is a space between all blocks\n\n\nThe order is: Description, Params, Return and Exceptions\n\n\nAll params should be aligned as shown in the example\n\n\nNever use @inheritBlock. It is not useful at all and makes the\ncomprehension of the code so difficult\n\n\n\n\nTools\n\n\nWe provide you a way of converting your way of programming to ours. Why don't \nyou use these tools?\n\n\nPHP-CS-Fixer\n\n\n\n\n(Github repository)[https://github.com/FriendsOfPHP/PHP-CS-Fixer]\n\n\n\n\nThis library analyzes all the PHP source and tries to fix coding standards \nissues, using a custom definition set in the root of the project.\n\n\n?php\n\nreturn Symfony\\CS\\Config\\Config::create()\n    // use SYMFONY_LEVEL:\n    -\nlevel(Symfony\\CS\\FixerInterface::SYMFONY_LEVEL)\n    // and extra fixers:\n    -\nfixers(array(\n        'concat_with_spaces',\n        'multiline_spaces_before_semicolon',\n        'short_array_syntax',\n        '-remove_lines_between_uses'\n    ))\n    -\nfinder(\n        Symfony\\CS\\Finder\\DefaultFinder::create()\n            -\nin('src/')\n    )\n;\n\n\n\n\nThis library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows\n\n\nphp bin/php-cs-fixer fix\n\n\n\n\nBecause the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.\n\n\nPHP-Formatter\n\n\n\n\n(Github repository)[https://github.com/mmoreram/php-formatter]\n\n\n\n\nAnother simple php formatter. This one will just format your class headers, \nsetting the project headers in your PHP classes, and will sort all use statements in\norder to comply with a given specification.\n\n\nThis library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows:\n\n\nphp bin/php-formatter formatter:use:sort src/\nphp bin/php-formatter formatter:header:fix src/\n\n\n\n\nBecause the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.", 
            "title": "Code"
        }, 
        {
            "location": "/book/standards/code/#coding-standards", 
            "text": "We have noticed that everyone has a different way of developing. In our team, \nsome people place the braces at the end of the class definition, while other\npeople place them in a new line.  Is anyone wrong? Absolutely not, even PHP has standards since long time\nago, and besides anyone should also be able to work the way they want.  But in Elcodi we have some standards for our code.  Small classes and methods  Each class should be small enough to contain specific information. Remember to\nuse small methods (no more than 20 lines) and to take care of their complexity.\nThe more complex a method is, the harder to understand what is all\nabout.  PHPDoc  This is an important part of the project.  All methods must be explained for humans. Some people think that the code should\nbe self-explanatory, and we agree on that. This doesn't mean that all people \nshould read the code to understand what a method is intended for.  Pretending them to understand our method by its code is to prevent them to focus \non their own business logic, and can hinder development speed.  All methods must follow these rules as well, related to PHP Doc format  /**\n * This is my detailed description about what my code is intended for\n * I can use as many lines as possible.\n * I repeat, as many lines as possible.\n *\n * @param MyObject $myObject My object description\n * @param string   $info     Some information\n * @param integer  $number   Some number\n *\n * @return Factory Description of the result\n *\n * @throws AnException Scenario when this exception is thrown\n */  Using this kind of blocks there are some tips we all need to take into account.   There is a space between all blocks  The order is: Description, Params, Return and Exceptions  All params should be aligned as shown in the example  Never use @inheritBlock. It is not useful at all and makes the\ncomprehension of the code so difficult", 
            "title": "Coding Standards"
        }, 
        {
            "location": "/book/standards/code/#tools", 
            "text": "We provide you a way of converting your way of programming to ours. Why don't \nyou use these tools?  PHP-CS-Fixer   (Github repository)[https://github.com/FriendsOfPHP/PHP-CS-Fixer]   This library analyzes all the PHP source and tries to fix coding standards \nissues, using a custom definition set in the root of the project.  ?php\n\nreturn Symfony\\CS\\Config\\Config::create()\n    // use SYMFONY_LEVEL:\n    - level(Symfony\\CS\\FixerInterface::SYMFONY_LEVEL)\n    // and extra fixers:\n    - fixers(array(\n        'concat_with_spaces',\n        'multiline_spaces_before_semicolon',\n        'short_array_syntax',\n        '-remove_lines_between_uses'\n    ))\n    - finder(\n        Symfony\\CS\\Finder\\DefaultFinder::create()\n            - in('src/')\n    )\n;  This library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows  php bin/php-cs-fixer fix  Because the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.  PHP-Formatter   (Github repository)[https://github.com/mmoreram/php-formatter]   Another simple php formatter. This one will just format your class headers, \nsetting the project headers in your PHP classes, and will sort all use statements in\norder to comply with a given specification.  This library is a dependency of the project, but only in development \nenvironment, so while you are developing, if you have already updated your \ncomposer dependencies, you can run the fixer as follows:  php bin/php-formatter formatter:use:sort src/\nphp bin/php-formatter formatter:header:fix src/  Because the dependency is set using an specific version of the code, all \ndevelopers will fix the code the same way.", 
            "title": "Tools"
        }, 
        {
            "location": "/book/standards/dependency-injection/", 
            "text": "Dependency Injection\n\n\nWe care as well on how Elcodi services are defined in the Symfony \nDependency Injection container, in order to make easier for the final user to\nremember the name of the service given the namespace of the class.\n\n\nFirst of all what you need to know is that all services in Elcodi ecosystem \nstart with \nelcodi.\n.\n\n\nFor example\n\n\nelcodi.event_dispatcher.cart\nelcodi.manager.cart\n\n\n\n\nWe have structured all definitions in two, three or four levels.\n\n\nTwo levels services\n\n\nElcodi specific and most important services in Elcodi ecosystem. These services\ncannot be grouped by any kind of \nnamespace\n because they are not an \nimplementation of any family.\n\n\nelcodi.languages\nelcodi.languages_iso\nelcodi.languages_iso_array\nelcodi.locale\n\n\n\n\nThree levels services\n\n\nMost of services will have three levels of definition. Let's analyze previous\nexamples:\n\n\nelcodi.event_dispatcher.cart\n\n\n\n\nFirst level\n is always \nelcodi\n. This will help you identifying all Elcodi's\ndefinition spectre.\n\n\nSecond level\n is the group or the final meaning of such service. For example,\nin this example our service will be an EventDispatcher.\nWe have some examples of different kind of services in our project\n\n\nelcodi.event_dispatcher.cart\nelcodi.event_listener.address_clone_update_carts\nelcodi.manager.cart\nelcodi.wrapper.cart\nelcodi.factory.cart\nelcodi.repository.cart\nelcodi.object_manager.cart\nelcodi.director.cart\nelcodi.transformer.cart_order\n\n\n\n\nThird level\n is the name of given type. In last example we were creating, for\nexample, the cart factory, or the cart event dispatcher. This last element has\nnothing to do with the name of the component, and must be extremely related with\nthe content of the class.\n\n\nFour levels services\n\n\nWe use four levels of definition when we define adapters.\n\n\nFirst level\n is always \nelcodi\n. This will help you identifying all Elcodi's\ndefinition spectre.\n\n\nSecond level\n is always \nadapter\n. This will help you identifying that such\nservice is not a permanent class but an adapter of an existing port.\n\n\nThird level\n is the name of the port. In this example our port is\n\ncurrency_exchange_rate\n, a way of calculating rates between currencies.\n\n\nelcodi.adapter.currency_exchange_rate.open_exchange\n\n\n\n\nFourth level\n is the name of the adapter. In the last example, our adapter is\n\nopen_exchange\n, a website that implements this feature.", 
            "title": "Dependency injection"
        }, 
        {
            "location": "/book/standards/dependency-injection/#dependency-injection", 
            "text": "We care as well on how Elcodi services are defined in the Symfony \nDependency Injection container, in order to make easier for the final user to\nremember the name of the service given the namespace of the class.  First of all what you need to know is that all services in Elcodi ecosystem \nstart with  elcodi. .  For example  elcodi.event_dispatcher.cart\nelcodi.manager.cart  We have structured all definitions in two, three or four levels.  Two levels services  Elcodi specific and most important services in Elcodi ecosystem. These services\ncannot be grouped by any kind of  namespace  because they are not an \nimplementation of any family.  elcodi.languages\nelcodi.languages_iso\nelcodi.languages_iso_array\nelcodi.locale  Three levels services  Most of services will have three levels of definition. Let's analyze previous\nexamples:  elcodi.event_dispatcher.cart  First level  is always  elcodi . This will help you identifying all Elcodi's\ndefinition spectre.  Second level  is the group or the final meaning of such service. For example,\nin this example our service will be an EventDispatcher.\nWe have some examples of different kind of services in our project  elcodi.event_dispatcher.cart\nelcodi.event_listener.address_clone_update_carts\nelcodi.manager.cart\nelcodi.wrapper.cart\nelcodi.factory.cart\nelcodi.repository.cart\nelcodi.object_manager.cart\nelcodi.director.cart\nelcodi.transformer.cart_order  Third level  is the name of given type. In last example we were creating, for\nexample, the cart factory, or the cart event dispatcher. This last element has\nnothing to do with the name of the component, and must be extremely related with\nthe content of the class.  Four levels services  We use four levels of definition when we define adapters.  First level  is always  elcodi . This will help you identifying all Elcodi's\ndefinition spectre.  Second level  is always  adapter . This will help you identifying that such\nservice is not a permanent class but an adapter of an existing port.  Third level  is the name of the port. In this example our port is currency_exchange_rate , a way of calculating rates between currencies.  elcodi.adapter.currency_exchange_rate.open_exchange  Fourth level  is the name of the adapter. In the last example, our adapter is open_exchange , a website that implements this feature.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/book/standards/packages-structure/", 
            "text": "Packages Structure\n\n\nA component must be treated as a simple PHP library. This means that it must be\nframework agnostic. At the beginning, Elcodi was a set of Bundles, divided by\nconcerns or boundaries, and implemented as a single Symfony-framework Bundle.\n\n\nThis was the root of some disagreements, and of course, like every single\nimplementation of Open Source, but we noticed that there was an opinion repeated\nonce and again by some users.\n\n\n\n\nThis project is Framework dependent.\n\n\n\n\nWe thought that being a Symfony dependent project was a good idea, but we had to \ndecide what to be dependent on. Finally, we decided that Elcodi had to be\ncoupled to Symfony components and Doctrine library, so we had to split between\nsimple PHP libraries (Components) and Symfony Framework adaptations of these\nlibraries (Bundles).\n\n\nComponent Structure\n\n\nAs we have said before, a component is just a PHP library. Think about it, we could use the Cart\nclasses in our own project, far from Symfony Framework, and because we don't \nwant all the Framework dependencies inside our \nvendor/\n folder, maybe we should\nonly require the classes and their dependencies.\n\n\nThis is what a component is. Just classes.\n\n\nSo inside a component you will find a simple categorization of objects. All \ncomponents follow the same structure.\n\n\nCart\n  |\n  |- Entity\n  |    |- Interfaces\n  |    |    |- CartInterface.php\n  |    |- Abstracts\n  |    |    |- AbstractCart.php\n  |    |- Cart.php\n  |\n  |- Factory\n  |    |- CartFactory.php\n  |\n  |- Repository\n  |    |- CartRepository.php\n  |\n  |- Services\n  |    |- CartManager.php\n  |\n  |- Wrapper\n  |    |- CartWrapper.php\n  |\n  |- Transformer\n  |    |- CartOrderTransformer.php\n  |\n  |- Event\n  |    |- OnOrderCreatedEvent.php\n  |\n  |- EventListener\n  |    |- CartEventListener.php\n  |\n  |- EventDispatcher\n  |    |- CartEventDispatcher.php\n  |\n  |- Controller\n  |    |- ImageUploadController.php\n  |\n  |- Command\n       |- SitemapProfileCommand.php\n\n\n\n\nThis is just a sample of how a Component is structured, and how you should \nstructure your project if you want to follow our way of doing things.\n\n\n\n\nThis does not mean that this one is the best way of structuring your code, or\ndoes not mean that there is not another way of doing it. Is just our\nimplementation and the one we suggest you.", 
            "title": "Packages structure"
        }, 
        {
            "location": "/book/standards/packages-structure/#packages-structure", 
            "text": "A component must be treated as a simple PHP library. This means that it must be\nframework agnostic. At the beginning, Elcodi was a set of Bundles, divided by\nconcerns or boundaries, and implemented as a single Symfony-framework Bundle.  This was the root of some disagreements, and of course, like every single\nimplementation of Open Source, but we noticed that there was an opinion repeated\nonce and again by some users.   This project is Framework dependent.   We thought that being a Symfony dependent project was a good idea, but we had to \ndecide what to be dependent on. Finally, we decided that Elcodi had to be\ncoupled to Symfony components and Doctrine library, so we had to split between\nsimple PHP libraries (Components) and Symfony Framework adaptations of these\nlibraries (Bundles).  Component Structure  As we have said before, a component is just a PHP library. Think about it, we could use the Cart\nclasses in our own project, far from Symfony Framework, and because we don't \nwant all the Framework dependencies inside our  vendor/  folder, maybe we should\nonly require the classes and their dependencies.  This is what a component is. Just classes.  So inside a component you will find a simple categorization of objects. All \ncomponents follow the same structure.  Cart\n  |\n  |- Entity\n  |    |- Interfaces\n  |    |    |- CartInterface.php\n  |    |- Abstracts\n  |    |    |- AbstractCart.php\n  |    |- Cart.php\n  |\n  |- Factory\n  |    |- CartFactory.php\n  |\n  |- Repository\n  |    |- CartRepository.php\n  |\n  |- Services\n  |    |- CartManager.php\n  |\n  |- Wrapper\n  |    |- CartWrapper.php\n  |\n  |- Transformer\n  |    |- CartOrderTransformer.php\n  |\n  |- Event\n  |    |- OnOrderCreatedEvent.php\n  |\n  |- EventListener\n  |    |- CartEventListener.php\n  |\n  |- EventDispatcher\n  |    |- CartEventDispatcher.php\n  |\n  |- Controller\n  |    |- ImageUploadController.php\n  |\n  |- Command\n       |- SitemapProfileCommand.php  This is just a sample of how a Component is structured, and how you should \nstructure your project if you want to follow our way of doing things.   This does not mean that this one is the best way of structuring your code, or\ndoes not mean that there is not another way of doing it. Is just our\nimplementation and the one we suggest you.", 
            "title": "Packages Structure"
        }, 
        {
            "location": "/book/workflows/cart/", 
            "text": "Using the Cart\n\n\nOne of the master pieces of Elcodi is the Cart Component. In this chapter we \nwill bring you some tips for a proper usage of this Cart.", 
            "title": "Cart"
        }, 
        {
            "location": "/book/workflows/cart/#using-the-cart", 
            "text": "One of the master pieces of Elcodi is the Cart Component. In this chapter we \nwill bring you some tips for a proper usage of this Cart.", 
            "title": "Using the Cart"
        }, 
        {
            "location": "/book/bundles/extensions/", 
            "text": "Bundle Extensions\n\n\nThe CoreBundle has general classes that enhance the developer experience to\nreduce boilerplate, enforce the opinions of the framework, improve or ensure\nfunctioning of the underlying Symfony framework and overall make life easier\nworking with the common needs of elcodi bundles.\n\n\nAbstractExtension\n is the base class that needs to be extended when\nbuilding your own bundle extension classes. This class takes care of the way\nin which configuration is handled in elcodi framework.\nFirstly the class require an extension name which is a snake case version of\nthe bundle for which the extension is created. This name is used to build the\nroot element of the configuration tree of the extension. And it will make\nlife easier to find a certain bundle configuration because elcodi\nfollows a common system-wide nomenclature for extension names as well.\n\n\n// Bundle Extension Class\n\n/**\n * @var string\n *\n * Extension name\n */\nconst EXTENSION_NAME = 'elcodi_attribute';\n\n\n/**\n * Returns the extension alias, same value as extension name\n *\n * @return string The alias\n */\npublic function getAlias()\n{\n    return static::EXTENSION_NAME;\n}\n\n\n\n\nThe \nAbstractConfiguration\n class is the base class for all bundle\nconfigurations. Together with the \nAbstractExtension\n form the\nfoundation to enforce elcodi practices in bundles. It also has built-in the\nimplemented mapping configuration node for configuring the respective entity\nmapping override. This configuration tree is always the same so there is\nno need to specify it each time on your custom extension.\n\n\n// Bundle Extension Class\n\n/**\n * Return a new Configuration instance.\n *\n * If object returned by this method is an instance of\n * ConfigurationInterface, extension will use the Configuration to read all\n * bundle config definitions.\n *\n * Also will call getParametrizationValues method to load some config values\n * to internal parameters.\n *\n * @return ConfigurationInterface Configuration file\n */\nprotected function getConfigurationInstance()\n{\n    return new Configuration(static::EXTENSION_NAME);\n}\n\n\n\n\nThe configuration class is precooked in the core bundles which already knows\nthe entities that are exposed to be overridden.\n\n\nThese two abstract classes above serve to generalize the configuration\nloading in a more elegant object oriented way. You no longer have to\nimplement each method of the base Symfony interfaces for extensions but you\nonly have to return certain name values and arrays of values on a subset of\nspecific methods.\n\n\nIn addition to this things like the extension instance, the configuration\ninstance, and array of parameters are pushed back into the container\nwhether as object resources or in the parameter bag of the container.\nThese is very useful when doing the mapping override and resolving of\nparameters as we will see later on.\n\n\nLet's for example load configuration files!\n\n\nOne has to only list the names of the configuration files that the bundle\nshould load and they will be automatically loaded via a file locator one by\none. The only thing told to the extension class is the configuration files\nlocation and which ones to load. If \ngetConfigFiles\n returns an empty\nlist then nothing will be loaded.\n\n\n// Bundle Extension Class\n\n/**\n * Get the Config file location\n *\n * @return string Config file location\n */\npublic function getConfigFilesLocation()\n{\n    return __DIR__ . '/../Resources/config';\n}\n\n/**\n * Config files to load\n *\n * @param array $config Configuration array\n *\n * @return array Config files\n */\npublic function getConfigFiles(array $config)\n{\n    return [\n        'factories',\n        'repositories',\n        'objectManagers',\n        'directors',\n    ];\n}\n\n\n\n\nLet's now override some mapping!\n\n\nOverriding the mapping on the doctrine section of the container cannot\nbe done simply via a compiler pass or on the extension, especially\nwhen we also want to use parametrized class names. Elcodi base classes\nhave already solved this for us using the prepend Symfony container\nfeature via implementing the \nPrependExtensionInterface\n interface.\nThis method allows us to override sections of other bundles and yet\nkeep the flexibility of using parameters that are resolved in the\ncontainer and that can be customized.\n\n\nIf we are to override mapping then our bundle extension should\nimplement the interface \nEntitiesOverridableExtensionInterface\n\nin addition to extending the \nAbstractExtension\n class.\nThe method \ngetEntitiesOverrides\n from the interface should return\na key value array where the key is the original interface and the value\nis the fully qualified class name or parameter.\nThe \nAbstractExtension\n takes this array and prepends this\nconfiguration into the container \ndoctrine\n and \nelcodi_core\n\nsections thereby achieving the wanted dynamic mapping behavior.\n\n\n// Bundle Extension Class\n\n/**\n * Get entities overrides.\n *\n * Result must be an array with:\n * index: Original Interface\n * value: Parameter where class is defined.\n *\n * @return array Overrides definition\n */\npublic function getEntitiesOverrides()\n{\n    return [\n        'Elcodi\\Component\\Attribute\\Entity\\Interfaces\\AttributeInterface' =\n 'elcodi.entity.attribute.class',\n        'Elcodi\\Component\\Attribute\\Entity\\Interfaces\\ValueInterface' =\n 'elcodi.entity.attribute_value.class',\n    ];\n}\n\n/**\n * Load Parametrization definition\n *\n * return array(\n *      'parameter1' =\n $config['parameter1'],\n *      'parameter2' =\n $config['parameter2'],\n *      ...\n * );\n *\n * @param array $config Bundles config values\n *\n * @return array Parametrization values\n */\nprotected function getParametrizationValues(array $config)\n{\n    return [\n        \nelcodi.entity.attribute.class\n =\n $config['mapping']['attribute']['class'],\n        \nelcodi.entity.attribute.mapping_file\n =\n $config['mapping']['attribute']['mapping_file'],\n        \nelcodi.entity.attribute.manager\n =\n $config['mapping']['attribute']['manager'],\n        \nelcodi.entity.attribute.enabled\n =\n $config['mapping']['attribute']['enabled'],\n\n        \nelcodi.entity.attribute_value.class\n =\n $config['mapping']['value']['class'],\n        \nelcodi.entity.attribute_value.mapping_file\n =\n $config['mapping']['value']['mapping_file'],\n        \nelcodi.entity.attribute_value.manager\n =\n $config['mapping']['value']['manager'],\n        \nelcodi.entity.attribute_value.enabled\n =\n $config['mapping']['value']['enabled'],\n    ];\n}\n\n\n\n\nAs you can see in the last method we can also provide parameterizable values\nfrom our configuration and plug them to be used during the mapping override.\n\n\nIf you are still unsure of how to use these base classes. Don't worry just\ntake a peek at the extensions defined for instance in bamboo project. These\nclasses are even simpler because they don't need to do any mapping override\nfor the core bundles anymore since this is already done. So they become\nplaces where we just hook configuration files that usually just have service\ndefinitions for our glue services.\n\n\nnamespace Elcodi\\Admin\\AttributeBundle\\DependencyInjection;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\Abstracts\\AbstractExtension;\n\n/**\n * Class AdminAttributeExtension\n */\nclass AdminAttributeExtension extends AbstractExtension\n{\n/**\n * @var string\n *\n * Extension name\n */\nconst EXTENSION_NAME = 'admin_attribute';\n\n/**\n * Get the Config file location\n *\n * @return string Config file location\n */\npublic function getConfigFilesLocation()\n{\n    return __DIR__ . '/../Resources/config';\n}\n\n/**\n * Config files to load\n *\n * return array(\n *      'file1.yml',\n *      'file2.yml',\n *      ...\n * );\n *\n * @param array $config Config\n *\n * @return array Config files\n */\npublic function getConfigFiles(array $config)\n{\n    return [\n        'formTypes',\n    ];\n}\n\n/**\n * Returns the extension alias, same value as extension name\n *\n * @return string The alias\n */\npublic function getAlias()\n{\n    return self::EXTENSION_NAME;\n}\n}", 
            "title": "Extensions"
        }, 
        {
            "location": "/book/bundles/extensions/#bundle-extensions", 
            "text": "The CoreBundle has general classes that enhance the developer experience to\nreduce boilerplate, enforce the opinions of the framework, improve or ensure\nfunctioning of the underlying Symfony framework and overall make life easier\nworking with the common needs of elcodi bundles.  AbstractExtension  is the base class that needs to be extended when\nbuilding your own bundle extension classes. This class takes care of the way\nin which configuration is handled in elcodi framework.\nFirstly the class require an extension name which is a snake case version of\nthe bundle for which the extension is created. This name is used to build the\nroot element of the configuration tree of the extension. And it will make\nlife easier to find a certain bundle configuration because elcodi\nfollows a common system-wide nomenclature for extension names as well.  // Bundle Extension Class\n\n/**\n * @var string\n *\n * Extension name\n */\nconst EXTENSION_NAME = 'elcodi_attribute';\n\n\n/**\n * Returns the extension alias, same value as extension name\n *\n * @return string The alias\n */\npublic function getAlias()\n{\n    return static::EXTENSION_NAME;\n}  The  AbstractConfiguration  class is the base class for all bundle\nconfigurations. Together with the  AbstractExtension  form the\nfoundation to enforce elcodi practices in bundles. It also has built-in the\nimplemented mapping configuration node for configuring the respective entity\nmapping override. This configuration tree is always the same so there is\nno need to specify it each time on your custom extension.  // Bundle Extension Class\n\n/**\n * Return a new Configuration instance.\n *\n * If object returned by this method is an instance of\n * ConfigurationInterface, extension will use the Configuration to read all\n * bundle config definitions.\n *\n * Also will call getParametrizationValues method to load some config values\n * to internal parameters.\n *\n * @return ConfigurationInterface Configuration file\n */\nprotected function getConfigurationInstance()\n{\n    return new Configuration(static::EXTENSION_NAME);\n}  The configuration class is precooked in the core bundles which already knows\nthe entities that are exposed to be overridden.  These two abstract classes above serve to generalize the configuration\nloading in a more elegant object oriented way. You no longer have to\nimplement each method of the base Symfony interfaces for extensions but you\nonly have to return certain name values and arrays of values on a subset of\nspecific methods.  In addition to this things like the extension instance, the configuration\ninstance, and array of parameters are pushed back into the container\nwhether as object resources or in the parameter bag of the container.\nThese is very useful when doing the mapping override and resolving of\nparameters as we will see later on.  Let's for example load configuration files!  One has to only list the names of the configuration files that the bundle\nshould load and they will be automatically loaded via a file locator one by\none. The only thing told to the extension class is the configuration files\nlocation and which ones to load. If  getConfigFiles  returns an empty\nlist then nothing will be loaded.  // Bundle Extension Class\n\n/**\n * Get the Config file location\n *\n * @return string Config file location\n */\npublic function getConfigFilesLocation()\n{\n    return __DIR__ . '/../Resources/config';\n}\n\n/**\n * Config files to load\n *\n * @param array $config Configuration array\n *\n * @return array Config files\n */\npublic function getConfigFiles(array $config)\n{\n    return [\n        'factories',\n        'repositories',\n        'objectManagers',\n        'directors',\n    ];\n}  Let's now override some mapping!  Overriding the mapping on the doctrine section of the container cannot\nbe done simply via a compiler pass or on the extension, especially\nwhen we also want to use parametrized class names. Elcodi base classes\nhave already solved this for us using the prepend Symfony container\nfeature via implementing the  PrependExtensionInterface  interface.\nThis method allows us to override sections of other bundles and yet\nkeep the flexibility of using parameters that are resolved in the\ncontainer and that can be customized.  If we are to override mapping then our bundle extension should\nimplement the interface  EntitiesOverridableExtensionInterface \nin addition to extending the  AbstractExtension  class.\nThe method  getEntitiesOverrides  from the interface should return\na key value array where the key is the original interface and the value\nis the fully qualified class name or parameter.\nThe  AbstractExtension  takes this array and prepends this\nconfiguration into the container  doctrine  and  elcodi_core \nsections thereby achieving the wanted dynamic mapping behavior.  // Bundle Extension Class\n\n/**\n * Get entities overrides.\n *\n * Result must be an array with:\n * index: Original Interface\n * value: Parameter where class is defined.\n *\n * @return array Overrides definition\n */\npublic function getEntitiesOverrides()\n{\n    return [\n        'Elcodi\\Component\\Attribute\\Entity\\Interfaces\\AttributeInterface' =  'elcodi.entity.attribute.class',\n        'Elcodi\\Component\\Attribute\\Entity\\Interfaces\\ValueInterface' =  'elcodi.entity.attribute_value.class',\n    ];\n}\n\n/**\n * Load Parametrization definition\n *\n * return array(\n *      'parameter1' =  $config['parameter1'],\n *      'parameter2' =  $config['parameter2'],\n *      ...\n * );\n *\n * @param array $config Bundles config values\n *\n * @return array Parametrization values\n */\nprotected function getParametrizationValues(array $config)\n{\n    return [\n         elcodi.entity.attribute.class  =  $config['mapping']['attribute']['class'],\n         elcodi.entity.attribute.mapping_file  =  $config['mapping']['attribute']['mapping_file'],\n         elcodi.entity.attribute.manager  =  $config['mapping']['attribute']['manager'],\n         elcodi.entity.attribute.enabled  =  $config['mapping']['attribute']['enabled'],\n\n         elcodi.entity.attribute_value.class  =  $config['mapping']['value']['class'],\n         elcodi.entity.attribute_value.mapping_file  =  $config['mapping']['value']['mapping_file'],\n         elcodi.entity.attribute_value.manager  =  $config['mapping']['value']['manager'],\n         elcodi.entity.attribute_value.enabled  =  $config['mapping']['value']['enabled'],\n    ];\n}  As you can see in the last method we can also provide parameterizable values\nfrom our configuration and plug them to be used during the mapping override.  If you are still unsure of how to use these base classes. Don't worry just\ntake a peek at the extensions defined for instance in bamboo project. These\nclasses are even simpler because they don't need to do any mapping override\nfor the core bundles anymore since this is already done. So they become\nplaces where we just hook configuration files that usually just have service\ndefinitions for our glue services.  namespace Elcodi\\Admin\\AttributeBundle\\DependencyInjection;\n\nuse Elcodi\\Bundle\\CoreBundle\\DependencyInjection\\Abstracts\\AbstractExtension;\n\n/**\n * Class AdminAttributeExtension\n */\nclass AdminAttributeExtension extends AbstractExtension\n{\n/**\n * @var string\n *\n * Extension name\n */\nconst EXTENSION_NAME = 'admin_attribute';\n\n/**\n * Get the Config file location\n *\n * @return string Config file location\n */\npublic function getConfigFilesLocation()\n{\n    return __DIR__ . '/../Resources/config';\n}\n\n/**\n * Config files to load\n *\n * return array(\n *      'file1.yml',\n *      'file2.yml',\n *      ...\n * );\n *\n * @param array $config Config\n *\n * @return array Config files\n */\npublic function getConfigFiles(array $config)\n{\n    return [\n        'formTypes',\n    ];\n}\n\n/**\n * Returns the extension alias, same value as extension name\n *\n * @return string The alias\n */\npublic function getAlias()\n{\n    return self::EXTENSION_NAME;\n}\n}", 
            "title": "Bundle Extensions"
        }, 
        {
            "location": "/book/bundles/plugins/", 
            "text": "Plugins\n\n\nWe want to introduce you what is a Plugin when we talk about Elcodi. Indeed,\nthis question has a very fast abstract answer that will, surely, give you some\nextra calmness.\n\n\nA Plugin is a Bundle.\n\n\nYes, when we talk about Plugins, we talk about Symfony Bundles, with a simple \nand pre-defined specification. And is this specification what we will show you\nproperly, in order to help you understanding existing plugins and composing new\nones.\n\n\nBundle\n\n\nLike any Bundle, a Plugin needs to have its own Bundle class. This is usually\nplaced in the root of the bundle, and should be called as much specifically as\npossible, in order to avoid collisions.\n\n\n\n\nEven if two bundles share the same name, the uniqueness of each Plugin is \ndefined by its namespace, so even in this scenario, your Elcodi installation\nwill work properly.\n\n\n\n\nLet's see an example of a bundle. We will work along this document with our\nfirst Plugin, the DisqusBundle.\n\n\nnamespace Elcodi\\Plugin\\DisqusBundle;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Component\\Plugin\\Interfaces\\PluginInterface;\n\n/**\n * Class ElcodiDisqusBundle\n */\nclass ElcodiDisqusBundle extends Bundle implements PluginInterface\n{\n    // ...\n}\n\n\n\n\nImplementing \nPluginInterface\n is the way the kernel has to identify if a bundle\nhas to be treated as a Plugin\n\n\nDefinition\n\n\nThere is a very simple way to define a Plugin. What is the name of the plugin, \nwhat are the fields that will configure it, and some more information is what\nyou will have to place in the \nplugin.yml\n file.\n\n\n\n\nThis file must be placed in the root of the Bundle\n\n\n\n\nLet's see an example of how the DisqusPlugin is configured.\n\n\nplugin:\n    type: plugin\n    category: comments\n    name: Discuss\n    description: |\n        Disqus integration for your shop\n    fa_icon: comment-o\n    fields:\n        disqus_identifier:\n            type: text\n            label: elcodi_plugin.disqus.disqus_identifier\n        disqus_enabled_product:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_product\n        disqus_enabled_blog_post:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_blog_post\n\n\n\n\nYou can define these items:\n\n\n\n\ntype: You must define your Plugin as a simple plugin or as a template.\n\n\ncategory: You can tag it as well. Social, comments, payment...\n\n\nname: The name of your plugin\n\n\nvisible: This plugin will be visible to be configured\n\n\nfa_icon: Icon used, following the Awesome Fonts format\n\n\ndescription: Plugin description\n\n\nfields: Set of configurable fields\n\n\n\n\nEach field can be defined as follows:\n\n\n\n\ntype: Type of the field. This value will be used as field type in form\n\n\nrequired: This field must be configured in order to use this plugin\n\n\ndata: The value of the field\n\n\nlabel: Label of the field (You can use translations)\n\n\noptions: Array of options, needed if your field is checkbox or radio.", 
            "title": "Plugins"
        }, 
        {
            "location": "/book/bundles/plugins/#plugins", 
            "text": "We want to introduce you what is a Plugin when we talk about Elcodi. Indeed,\nthis question has a very fast abstract answer that will, surely, give you some\nextra calmness.  A Plugin is a Bundle.  Yes, when we talk about Plugins, we talk about Symfony Bundles, with a simple \nand pre-defined specification. And is this specification what we will show you\nproperly, in order to help you understanding existing plugins and composing new\nones.  Bundle  Like any Bundle, a Plugin needs to have its own Bundle class. This is usually\nplaced in the root of the bundle, and should be called as much specifically as\npossible, in order to avoid collisions.   Even if two bundles share the same name, the uniqueness of each Plugin is \ndefined by its namespace, so even in this scenario, your Elcodi installation\nwill work properly.   Let's see an example of a bundle. We will work along this document with our\nfirst Plugin, the DisqusBundle.  namespace Elcodi\\Plugin\\DisqusBundle;\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\n\nuse Elcodi\\Component\\Plugin\\Interfaces\\PluginInterface;\n\n/**\n * Class ElcodiDisqusBundle\n */\nclass ElcodiDisqusBundle extends Bundle implements PluginInterface\n{\n    // ...\n}  Implementing  PluginInterface  is the way the kernel has to identify if a bundle\nhas to be treated as a Plugin  Definition  There is a very simple way to define a Plugin. What is the name of the plugin, \nwhat are the fields that will configure it, and some more information is what\nyou will have to place in the  plugin.yml  file.   This file must be placed in the root of the Bundle   Let's see an example of how the DisqusPlugin is configured.  plugin:\n    type: plugin\n    category: comments\n    name: Discuss\n    description: |\n        Disqus integration for your shop\n    fa_icon: comment-o\n    fields:\n        disqus_identifier:\n            type: text\n            label: elcodi_plugin.disqus.disqus_identifier\n        disqus_enabled_product:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_product\n        disqus_enabled_blog_post:\n            type: checkbox\n            label: elcodi_plugin.disqus.disqus_enabled_blog_post  You can define these items:   type: You must define your Plugin as a simple plugin or as a template.  category: You can tag it as well. Social, comments, payment...  name: The name of your plugin  visible: This plugin will be visible to be configured  fa_icon: Icon used, following the Awesome Fonts format  description: Plugin description  fields: Set of configurable fields   Each field can be defined as follows:   type: Type of the field. This value will be used as field type in form  required: This field must be configured in order to use this plugin  data: The value of the field  label: Label of the field (You can use translations)  options: Array of options, needed if your field is checkbox or radio.", 
            "title": "Plugins"
        }, 
        {
            "location": "/book/bundles/templates/", 
            "text": "Templates", 
            "title": "Templates"
        }, 
        {
            "location": "/book/bundles/templates/#templates", 
            "text": "", 
            "title": "Templates"
        }, 
        {
            "location": "/book/philosophy/elcodi/", 
            "text": "Elcodi Philosophy", 
            "title": "Elcodi"
        }, 
        {
            "location": "/book/philosophy/elcodi/#elcodi-philosophy", 
            "text": "", 
            "title": "Elcodi Philosophy"
        }, 
        {
            "location": "/cookbook/", 
            "text": "Cookbook\n\n\nThe Elcodi Cookbook is a set of recipes related to Elcodi development flow and\nthe Bamboo implementation. Each one solves a specific problem or a specific\nscenario.\n\n\nImplementation\n\n\n\n\nHow to Implement an Entity\n\n\nHow to Implement a Factory\n\n\nHow to Implement a Repository\n\n\nHow to Implement a Form Type\n\n\nHow to Implement a Controller or a Command\n\n\n\n\nInstallation\n\n\n\n\nHow to Install dependent Bundles\n\n\n\n\nOverwrite Elcodi \n Bamboo\n\n\n\n\nHow to Overwrite a Parameter\n\n\nHow to Overwrite an Entity\n\n\nHow to Overwrite a Service\n\n\n\n\nCommon Caveats\n\n\n\n\nRunning the Test Suite", 
            "title": "Home"
        }, 
        {
            "location": "/cookbook/#cookbook", 
            "text": "The Elcodi Cookbook is a set of recipes related to Elcodi development flow and\nthe Bamboo implementation. Each one solves a specific problem or a specific\nscenario.  Implementation   How to Implement an Entity  How to Implement a Factory  How to Implement a Repository  How to Implement a Form Type  How to Implement a Controller or a Command   Installation   How to Install dependent Bundles   Overwrite Elcodi   Bamboo   How to Overwrite a Parameter  How to Overwrite an Entity  How to Overwrite a Service   Common Caveats   Running the Test Suite", 
            "title": "Cookbook"
        }, 
        {
            "location": "/cookbook/caveats/running-test-suite/", 
            "text": "Running the Test Suite\n\n\nBoth projects have a set of Unit, Functional and Behavioral tests. It is important\nto know how to run them all, and how to do that in a fast way\n\n\nelcodi/elcodi\n\n\nRunning the test suite for elcodi/elcodi is simply one command:\n\n\nphp bin/phpunit\n\n\n\n\nElcodi tests are ran against folder \n/tmp/Elcodi\n, so a good practice in this\ncase is to ensure that accesses to this folder are fast enough. For this reason, we can\ncreate a \ntmpfs\n, a mounted file system stored in volatile memory instead of a \npersistent storage device.\n\n\nrm -Rf /tmp/Elcodi\nsudo mkdir /tmp/Elcodi\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Elcodi/\n\n\n\n\nWith this trick, your tests will run extremely faster than before.\n\n\nElcodi project uses as well a Testing Booster called\n\nFixturesBoosterBundle\n. This\nproject overwrites the Doctrine command \ndoctrine:fixtures:load\n with a boosted\nversion.\n\n\nIn order to avoid keeping state on a temporal database you may need to remove \ntemporal files generated by this booster on your tmp folder:\n\n\nrm -rf /tmp/*.backup.database\n\n\n\n\nIn addition to this it is required to flush the redis database:\n\n\nredis-cli flushall\n\n\n\n\nProblems can turn very cryptic if you are using an expired redis database.\n\n\nelcodi/bamboo\n\n\nRunning the test suite for elcodi/bamboo is also simple:\n\n\nphp bin/behat\nphp bin/phpunit -c app/\n\n\n\n\nAs explained before, Bamboo tests also can be ran against a \ntmpfs\n unit.\n\n\nrm -Rf /tmp/Bamboo\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Bamboo\n\n\n\n\nYou can do the same with the cache folder, in order to make all reads really \nfaster.\n\n\nrm -Rf app/cache\nmkdir app/cache\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/cache\n\n\n\n\nIf you want to run a subset of the behat tests you can specify the tag as\nan option:\n\n\nphp bin/behat --tags=\nstore\n\n\n\n\n\nThis will only run the feature scenarios tagged with @store, e.g.:\n\n\n# bamboo/features/store/cart.feature\n@store @cart\nFeature: Store cart\n  In order to use the cart\n  As a visitor or logged user\n  I need to be able to add products into it and access the checkout\n\n  # ...\n\n\n\n\nA typical use case when to use this feature is when you want to\nrun only the tests that require javascript.", 
            "title": "Running test suite"
        }, 
        {
            "location": "/cookbook/caveats/running-test-suite/#running-the-test-suite", 
            "text": "Both projects have a set of Unit, Functional and Behavioral tests. It is important\nto know how to run them all, and how to do that in a fast way", 
            "title": "Running the Test Suite"
        }, 
        {
            "location": "/cookbook/caveats/running-test-suite/#elcodielcodi", 
            "text": "Running the test suite for elcodi/elcodi is simply one command:  php bin/phpunit  Elcodi tests are ran against folder  /tmp/Elcodi , so a good practice in this\ncase is to ensure that accesses to this folder are fast enough. For this reason, we can\ncreate a  tmpfs , a mounted file system stored in volatile memory instead of a \npersistent storage device.  rm -Rf /tmp/Elcodi\nsudo mkdir /tmp/Elcodi\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Elcodi/  With this trick, your tests will run extremely faster than before.  Elcodi project uses as well a Testing Booster called FixturesBoosterBundle . This\nproject overwrites the Doctrine command  doctrine:fixtures:load  with a boosted\nversion.  In order to avoid keeping state on a temporal database you may need to remove \ntemporal files generated by this booster on your tmp folder:  rm -rf /tmp/*.backup.database  In addition to this it is required to flush the redis database:  redis-cli flushall  Problems can turn very cryptic if you are using an expired redis database.", 
            "title": "elcodi/elcodi"
        }, 
        {
            "location": "/cookbook/caveats/running-test-suite/#elcodibamboo", 
            "text": "Running the test suite for elcodi/bamboo is also simple:  php bin/behat\nphp bin/phpunit -c app/  As explained before, Bamboo tests also can be ran against a  tmpfs  unit.  rm -Rf /tmp/Bamboo\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/Bamboo  You can do the same with the cache folder, in order to make all reads really \nfaster.  rm -Rf app/cache\nmkdir app/cache\nsudo mkdir /tmp/Bamboo\nsudo mount -t tmpfs -o size=512M tmpfs /tmp/cache  If you want to run a subset of the behat tests you can specify the tag as\nan option:  php bin/behat --tags= store   This will only run the feature scenarios tagged with @store, e.g.:  # bamboo/features/store/cart.feature\n@store @cart\nFeature: Store cart\n  In order to use the cart\n  As a visitor or logged user\n  I need to be able to add products into it and access the checkout\n\n  # ...  A typical use case when to use this feature is when you want to\nrun only the tests that require javascript.", 
            "title": "elcodi/bamboo"
        }, 
        {
            "location": "/cookbook/installation/install-dependent-bundles/", 
            "text": "How to Install dependent Bundles\n\n\nThis chapter is not only to show how to install a Dependent Bundle in Elcodi \nenvironment, but to show how to do it properly.\n\n\nPackage dependencies\n\n\nAll Bundles in Elcodi follow the same installation strategy than Symfony \nstandard packages. Elcodi uses composer for package dependencies, so each\nstandalone Elcodi repository comes with a properly configured \ncomposer.json\n \nfile.\n\n\nBut when we talk about Bundles in Symfony, defining the dependencies in the\ncomposer file is not enough. The Kernel will instance only the Bundles you\ndefine in \nAppKernel.php\n file, ignoring the real dependencies this Bundle has.\n\n\nSo, regarding this real problem, Elcodi has developed some business logic in\norder to solve this problem.\n\n\nFirst of all, let's take a look at a simple Symfony Bundle class.\n\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle\n{\n}\n\n\n\n\nMaybe this Bundle needs the instantiation of another bundle (previously added in\nthe composer definition), but is not defined anywhere. So... let's do that.\n\n\nThe first step is to define a set of Bundle namespaces that must be instanced\nbefore this Bundle.\n\n\nAll dependent Bundles will be instanced before this Bundle. This is because a\nBundle should be able to override another Bundle definition, and Symfony has in\nmost cases a \nLast defined wins\n strategy.\n\n\nuse Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\nuse Elcodi\\Bundle\\CoreBundle\\Interfaces\\DependentBundleInterface;\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle implements DependentBundleInterface\n{\n    /**\n     * Create instance of current bundle, and return dependent bundle namespaces\n     *\n     * @return array Bundle instances\n     */\n    public static function getBundleDependencies()\n    {\n        return [\n            'Elcodi\\Bundle\\UserBundle\\ElcodiUserBundle',\n            'Elcodi\\Bundle\\ProductBundle\\ElcodiProductBundle',\n            'Elcodi\\Bundle\\CurrencyBundle\\ElcodiCurrencyBundle',\n            'Elcodi\\Bundle\\StateTransitionMachineBundle\\ElcodiStateTransitionMachineBundle',\n            'Elcodi\\Bundle\\ShippingBundle\\ElcodiShippingBundle',\n            'Elcodi\\Bundle\\ConfigurationBundle\\ElcodiConfigurationBundle',\n            'Elcodi\\Bundle\\CoreBundle\\ElcodiCoreBundle',\n        ];\n    }\n}\n\n\n\n\nSo, what else? Is that enough?\n\n\nThen, in order to make it happen, we must use a specific method in our \n\nAppKernel\n class, using a Trait provided by \nElcodiCoreBundle\n.\n\n\nuse Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\nuse Elcodi\\Bundle\\TestCommonBundle\\Functional\\Abstracts\\AbstractElcodiKernel;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends AbstractElcodiKernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Register application bundles\n     *\n     * @return array Array of bundles instances\n     */\n    public function registerBundles()\n    {\n        return $this-\ngetBundleInstances([\n            '\\Elcodi\\Bundle\\CartBundle\\ElcodiCartBundle',\n        ]);\n    }\n}\n\n\n\n\nAnd that's it. Your kernel will instance your \nElcodiCartBundle\n bundle and all\nits dependencies.\n\n\n\n\nThis method will work as well, even if the Bundle has no dependencies or is\nnot extending DependentBundleInterface.\n\n\n\n\nUsing dependencies in your project\n\n\nIf you want to use this classes and methods in your Symfony project, you don't \nreally need to instance \nElcodiCoreBundle\n because you will not need any kind\nof Dependency Injection definition.\n\n\nYou only need to add \nelcodi/core-bundle\n in your package requirements and then\nuse the Interface and the Trait as is shown in this CookBook entry.", 
            "title": "Install dependent bundles"
        }, 
        {
            "location": "/cookbook/installation/install-dependent-bundles/#how-to-install-dependent-bundles", 
            "text": "This chapter is not only to show how to install a Dependent Bundle in Elcodi \nenvironment, but to show how to do it properly.  Package dependencies  All Bundles in Elcodi follow the same installation strategy than Symfony \nstandard packages. Elcodi uses composer for package dependencies, so each\nstandalone Elcodi repository comes with a properly configured  composer.json  \nfile.  But when we talk about Bundles in Symfony, defining the dependencies in the\ncomposer file is not enough. The Kernel will instance only the Bundles you\ndefine in  AppKernel.php  file, ignoring the real dependencies this Bundle has.  So, regarding this real problem, Elcodi has developed some business logic in\norder to solve this problem.  First of all, let's take a look at a simple Symfony Bundle class.  /**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle\n{\n}  Maybe this Bundle needs the instantiation of another bundle (previously added in\nthe composer definition), but is not defined anywhere. So... let's do that.  The first step is to define a set of Bundle namespaces that must be instanced\nbefore this Bundle.  All dependent Bundles will be instanced before this Bundle. This is because a\nBundle should be able to override another Bundle definition, and Symfony has in\nmost cases a  Last defined wins  strategy.  use Symfony\\Component\\HttpKernel\\Bundle\\Bundle;\nuse Elcodi\\Bundle\\CoreBundle\\Interfaces\\DependentBundleInterface;\n\n/**\n * ElcodiCartBundle Bundle\n */\nclass ElcodiCartBundle extends Bundle implements DependentBundleInterface\n{\n    /**\n     * Create instance of current bundle, and return dependent bundle namespaces\n     *\n     * @return array Bundle instances\n     */\n    public static function getBundleDependencies()\n    {\n        return [\n            'Elcodi\\Bundle\\UserBundle\\ElcodiUserBundle',\n            'Elcodi\\Bundle\\ProductBundle\\ElcodiProductBundle',\n            'Elcodi\\Bundle\\CurrencyBundle\\ElcodiCurrencyBundle',\n            'Elcodi\\Bundle\\StateTransitionMachineBundle\\ElcodiStateTransitionMachineBundle',\n            'Elcodi\\Bundle\\ShippingBundle\\ElcodiShippingBundle',\n            'Elcodi\\Bundle\\ConfigurationBundle\\ElcodiConfigurationBundle',\n            'Elcodi\\Bundle\\CoreBundle\\ElcodiCoreBundle',\n        ];\n    }\n}  So, what else? Is that enough?  Then, in order to make it happen, we must use a specific method in our  AppKernel  class, using a Trait provided by  ElcodiCoreBundle .  use Elcodi\\Bundle\\CoreBundle\\Traits\\BundleDependenciesResolver;\nuse Elcodi\\Bundle\\TestCommonBundle\\Functional\\Abstracts\\AbstractElcodiKernel;\n\n/**\n * Class AppKernel\n */\nclass AppKernel extends AbstractElcodiKernel\n{\n    use BundleDependenciesResolver;\n\n    /**\n     * Register application bundles\n     *\n     * @return array Array of bundles instances\n     */\n    public function registerBundles()\n    {\n        return $this- getBundleInstances([\n            '\\Elcodi\\Bundle\\CartBundle\\ElcodiCartBundle',\n        ]);\n    }\n}  And that's it. Your kernel will instance your  ElcodiCartBundle  bundle and all\nits dependencies.   This method will work as well, even if the Bundle has no dependencies or is\nnot extending DependentBundleInterface.   Using dependencies in your project  If you want to use this classes and methods in your Symfony project, you don't \nreally need to instance  ElcodiCoreBundle  because you will not need any kind\nof Dependency Injection definition.  You only need to add  elcodi/core-bundle  in your package requirements and then\nuse the Interface and the Trait as is shown in this CookBook entry.", 
            "title": "How to Install dependent Bundles"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-entity/", 
            "text": "How to Overwrite an Entity\n\n\nEach project is completely different, right? Elcodi is just one approach to an\nspecific e-commerce problem, but one of our goals is to provide a way for\noverwriting absolutely everything.\n\n\nIn this document we will show you how to properly overwrite any default entity\nimplementation with your own.\n\n\nExtending or Implementing\n\n\nEach entity has its own interface. It means that if you want to build your own\n\nCart\n, for example, your new implementation will need to implement the existing\nCart interface, in that case, \n\nElcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface\n.\n\n\nuse Elcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface;\n\n/**\n * New Cart implementation\n */\nclass NewCart implements CartInterface\n{\n\n}    \n\n\n\n\nYou can also create a new entity extending the default Cart implementation (at this point\nyour new entity will be implementing this interface by default). The advantage is\nthat you don't need to implement all the methods of the interface, but just overwrite\nthose that you want to change.\n\n\nuse Elcodi\\Component\\Cart\\Entity\\Cart;\n\n/**\n * New Cart implementation\n */\nclass NewCart extends Cart\n{\n\n}    \n\n\n\n\nBoth ways are valid depending on your implementation needs.\n\n\nUsing this new implementation\n\n\nOnce your new entity is implemented, you need to tell your application\nabout your new implementation.\n\n\nElcodi works with a project called \n\nSimpleDoctrineMapping\n. This\nlibrary enables each bundle to specify how its entities must be treated inside\nthe Symfony installation, instead of letting Doctrine decide this stuff using \n\nauto_mapping=true\n.\n\n\nEach Elcodi Bundle uses this library, so you can overwrite this information \nthrough each Bundle configuration. Let's see how CartBundle allows the user to\ndefine this information by exposing its configuration.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Cart\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Cart.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true\n\n\n\n\nIf you don't define anything, then these values are injected as default \nconfiguration values in CartBundle, so this is the way of overwriting the \ndefinition to start using our new Cart implementation.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: My\\New\\Bundle\\Entity\\NewCart\n\n\n\n\nAnd that's enough.\n\n\nChanging the mapping file\n\n\nOnce you have changed your entity, or just using the default entity \nimplementation, maybe you want to change the way the entity is mapped in your\ndatabase.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Cart.orm.yml'\n\n\n\n\nIn Elcodi we are actually using \nyml\n files for such definition, but you can use\nboth \nyml\n and \nxml\n files.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Cart.orm.xml'\n\n\n\n\nThe result will be the same, and the system will detect the file extension.\n\n\nUsing another Entity Manager\n\n\nBy default, all entities are managed by the default entity manager. You can \nchange this behavior just overwriting this configuration value. The selected entity\nmanager must exist in your Doctrine ORM definition.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine manager name\n            manager: another_entity_manager\n\n\n\n\nTake into account that related entities should share the same entity manager. For\nexample, in this example, because \nCart\n has several \nCartLine\n instances, it\nwould be not possible to have both tables managed separately by two different\nmanagers.\n\n\nDisabling an Entity\n\n\nMaybe you want to disable a specific entity. The most used strategy would be not\nto use this entity, even if the table is created, but we strongly think that \nyour model must be considered an essential part of your implementation, so you \ncan disable an entity with a single line.\n\n\nelcodi_cart:\n\n    mapping:\n        cart:\n            enabled: false", 
            "title": "Overwrite a entity"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-entity/#how-to-overwrite-an-entity", 
            "text": "Each project is completely different, right? Elcodi is just one approach to an\nspecific e-commerce problem, but one of our goals is to provide a way for\noverwriting absolutely everything.  In this document we will show you how to properly overwrite any default entity\nimplementation with your own.  Extending or Implementing  Each entity has its own interface. It means that if you want to build your own Cart , for example, your new implementation will need to implement the existing\nCart interface, in that case,  Elcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface .  use Elcodi\\Component\\Cart\\Entity\\Interfaces\\CartInterface;\n\n/**\n * New Cart implementation\n */\nclass NewCart implements CartInterface\n{\n\n}      You can also create a new entity extending the default Cart implementation (at this point\nyour new entity will be implementing this interface by default). The advantage is\nthat you don't need to implement all the methods of the interface, but just overwrite\nthose that you want to change.  use Elcodi\\Component\\Cart\\Entity\\Cart;\n\n/**\n * New Cart implementation\n */\nclass NewCart extends Cart\n{\n\n}      Both ways are valid depending on your implementation needs.  Using this new implementation  Once your new entity is implemented, you need to tell your application\nabout your new implementation.  Elcodi works with a project called  SimpleDoctrineMapping . This\nlibrary enables each bundle to specify how its entities must be treated inside\nthe Symfony installation, instead of letting Doctrine decide this stuff using  auto_mapping=true .  Each Elcodi Bundle uses this library, so you can overwrite this information \nthrough each Bundle configuration. Let's see how CartBundle allows the user to\ndefine this information by exposing its configuration.  elcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: Elcodi\\Component\\Cart\\Entity\\Cart\n            # Doctrine mapping file for this entity\n            mapping_file: '@ElcodiCartBundle/Resources/config/doctrine/Cart.orm.yml'\n            # Doctrine manager name\n            manager: default\n            # Is this entity enabled?\n            enabled: true  If you don't define anything, then these values are injected as default \nconfiguration values in CartBundle, so this is the way of overwriting the \ndefinition to start using our new Cart implementation.  elcodi_cart:\n\n    mapping:\n        cart:\n            # Cart entity implementing CartInterface\n            class: My\\New\\Bundle\\Entity\\NewCart  And that's enough.  Changing the mapping file  Once you have changed your entity, or just using the default entity \nimplementation, maybe you want to change the way the entity is mapped in your\ndatabase.  elcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Cart.orm.yml'  In Elcodi we are actually using  yml  files for such definition, but you can use\nboth  yml  and  xml  files.  elcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine mapping file for this entity\n            mapping_file: '@MyNewBundle/Resources/config/doctrine/Cart.orm.xml'  The result will be the same, and the system will detect the file extension.  Using another Entity Manager  By default, all entities are managed by the default entity manager. You can \nchange this behavior just overwriting this configuration value. The selected entity\nmanager must exist in your Doctrine ORM definition.  elcodi_cart:\n\n    mapping:\n        cart:\n            # Doctrine manager name\n            manager: another_entity_manager  Take into account that related entities should share the same entity manager. For\nexample, in this example, because  Cart  has several  CartLine  instances, it\nwould be not possible to have both tables managed separately by two different\nmanagers.  Disabling an Entity  Maybe you want to disable a specific entity. The most used strategy would be not\nto use this entity, even if the table is created, but we strongly think that \nyour model must be considered an essential part of your implementation, so you \ncan disable an entity with a single line.  elcodi_cart:\n\n    mapping:\n        cart:\n            enabled: false", 
            "title": "How to Overwrite an Entity"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-parameter/", 
            "text": "How to Overwrite a Parameter\n\n\nYou can overwrite Elcodi by using the file \napp/config/config_local.yml\n. This\nfile is loaded at the end of the \napp/config/config.yml\n file, allowing final \nusers to add custom elements, overriding all project definitions.\n\n\nWhy you should use \nconfig_local.yml\n file?\n\n\nWell, this file will never be improved nor evolved, so even if you pull into \nyour project last Elcodi versions, you will never have conflicts in that file.\n\n\nLet's see an example\n\n\n# app/config/config_local.yml\nparameters:\n    database_host: 10.0.0.1\n\nelcodi_currency:\n    currency:\n        default_currency: EUR\n        session_field_name: currency_id", 
            "title": "Overwrite a parameter"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-parameter/#how-to-overwrite-a-parameter", 
            "text": "You can overwrite Elcodi by using the file  app/config/config_local.yml . This\nfile is loaded at the end of the  app/config/config.yml  file, allowing final \nusers to add custom elements, overriding all project definitions.  Why you should use  config_local.yml  file?  Well, this file will never be improved nor evolved, so even if you pull into \nyour project last Elcodi versions, you will never have conflicts in that file.  Let's see an example  # app/config/config_local.yml\nparameters:\n    database_host: 10.0.0.1\n\nelcodi_currency:\n    currency:\n        default_currency: EUR\n        session_field_name: currency_id", 
            "title": "How to Overwrite a Parameter"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/", 
            "text": "How to overwrite a service\n\n\nTo overwrite a service you must create a new class in your project, extend the \nmain service and overwrite the methods you need to overwrite.\n\n\nuse Elcodi\\Component\\Cart\\Services\\CartManager;\n\n/**\n * New cart manager\n */\nclass NewCartManager extends CartManager\n{\n    /**\n     * Adds cartLine to Cart\n     *\n     * This method dispatches all Cart Check and Load events\n     * It should NOT be used to add a Purchasable to a Cart,\n     * by manually passing a newly crafted CartLine, since\n     * no product duplication check is performed: in that\n     * case CartManager::addProduct should be used\n     *\n     * @param CartInterface     $cart     Cart\n     * @param CartLineInterface $cartLine Cart line\n     *\n     * @return $this Self object\n     */\n    protected function addLine(\n        CartInterface $cart,\n        CartLineInterface $cartLine\n    ) {\n\n        // My own addLine implementation\n    }\n}\n\n\n\n\nFinally we need to let the project know that this new implementation is the one\nwe really want to use in our project. For this reason, we should redefine this\nservice in our \nconfig.yml\n file, and overwrite the main service implementation.\n\n\nservices:\n\n    elcodi.manager.cart:\n        cart: My\\New\\Bundle\\Services\\NewCartManager\n        arguments:\n            ...\n\n\n\n\nHaving done that, all the project will use your \nelcodi.manager.cart\n implementation \ninstead of the default one.", 
            "title": "Overwrite a service"
        }, 
        {
            "location": "/cookbook/overwrite/overwrite-a-service/#how-to-overwrite-a-service", 
            "text": "To overwrite a service you must create a new class in your project, extend the \nmain service and overwrite the methods you need to overwrite.  use Elcodi\\Component\\Cart\\Services\\CartManager;\n\n/**\n * New cart manager\n */\nclass NewCartManager extends CartManager\n{\n    /**\n     * Adds cartLine to Cart\n     *\n     * This method dispatches all Cart Check and Load events\n     * It should NOT be used to add a Purchasable to a Cart,\n     * by manually passing a newly crafted CartLine, since\n     * no product duplication check is performed: in that\n     * case CartManager::addProduct should be used\n     *\n     * @param CartInterface     $cart     Cart\n     * @param CartLineInterface $cartLine Cart line\n     *\n     * @return $this Self object\n     */\n    protected function addLine(\n        CartInterface $cart,\n        CartLineInterface $cartLine\n    ) {\n\n        // My own addLine implementation\n    }\n}  Finally we need to let the project know that this new implementation is the one\nwe really want to use in our project. For this reason, we should redefine this\nservice in our  config.yml  file, and overwrite the main service implementation.  services:\n\n    elcodi.manager.cart:\n        cart: My\\New\\Bundle\\Services\\NewCartManager\n        arguments:\n            ...  Having done that, all the project will use your  elcodi.manager.cart  implementation \ninstead of the default one.", 
            "title": "How to overwrite a service"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/", 
            "text": "How to Implement a Controller or a Command\n\n\nControllers and Commands in Elcodi are exactly the same than Controllers and \nCommands in Symfony. No difference between them. But in Elcodi we have a strong\nphilosophy about how to create them in order to be valid or usable in the Open\nSource environment.\n\n\nServices in Elcodi\n\n\nAll Elcodi Controllers and Commands are defined as services. This is because we\nare \nOverwriting Oriented Programming\n and we have in mind that every single\nimplementation sensible to be changed between projects must be easily \ncustomized.\n\n\nIn Symfony, and because Dependency Injection definition has a very well documented\noverwriting strategy, we have decided that everything must be defined as a \nservice.\n\n\nWe have a convention about how a Controller and a Command must be registered in\nyour DI container\n\n\nelcodi.controller.image_upload\nelcodi.command.populate_currency_rates\n\n\n\n\nOf course, and because it should only depend on the Symfony Components, but never\nthe Symfony Framework nor the FrameworkBundle, both implementations must not extend\nFramework classes.\n\n\nFramework Controllers in Bamboo\n\n\nWhen you work in Bamboo (or in your project on top of Elcodi Components and \nBundles) we don't recommend the usage of Controllers and Commands as services.\nWe think that both implementations are Entry Points and should be Framework\nrelated.\n\n\nThis means that your Controllers or Commands should never have business logic,\nand should place all this logic in your service layer.\n\n\nHaving said that, we recommend the usage of \nFrameworkBundle\n Controller class to\nendow your controllers with easy access to the DI container and a good set of\npre-built methods.\n\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n */\nclass CartController extends Controller\n{\n}\n\n\n\n\nFramework Commands in Bamboo\n\n\nWe have the same opinion for Commands and Controllers.\n\n\nuse Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\n\n/**\n * Cart controllers\n */\nclass MyCommand extends ContainerAwareCommand\n{\n}\n\n\n\n\nAnnotations in Bamboo Controllers\n\n\nIn Bamboo, we use annotations in all our controllers in order to make the code more\nunderstandable and to focus only on business logic. Annotations solve\nrepetitive things and should be perfectly documented.\n\n\n\n\nMagic? Yes, of course, same magic than yml readers, than Container\ncompilation, than service builds... so what?\n\n\n\n\nFor this reason, we are using \n\nControllerExtraBundle\n and\n\nSensioFrameworkExtraBundle\n.\n\n\nLet's see an example.\n\n\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Entity as AnnotationEntity;\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Form as AnnotationForm;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n *\n * @Route(\n *      path = \n/cart\n,\n * )\n */\nclass CartController extends Controller\n{\n    /**\n     * Cart view\n     *\n     * @param FormView      $formView Form view\n     * @param CartInterface $cart     Cart\n     *\n     * @return Response Response\n     *\n     * @Route(\n     *      path = \n,\n     *      name = \nstore_cart_view\n,\n     *      methods = {\nGET\n}\n     * )\n     *\n     * @AnnotationEntity(\n     *      class = {\n     *          \nfactory\n = \nelcodi.wrapper.cart\n,\n     *          \nmethod\n = \nloadCart\n,\n     *          \nstatic\n = false,\n     *      },\n     *      name = \ncart\n\n     * )\n     * @AnnotationForm(\n     *      class = \nstore_cart_form_type_cart\n,\n     *      name  = \nformView\n,\n     *      entity = \ncart\n,\n     * )\n     */\n    public function viewAction(\n        FormView $formView,\n        CartInterface $cart\n    ) {\n        // ...\n\n        return $this-\nrenderTemplate(\n            'Pages:cart-view.html.twig',\n            [\n                // ...\n            ]\n        );\n    }\n}\n\n\n\n\nYou can find some documentation of both annotation packages\n\n\n\n\nControllerExtraBundle\n\n\nSensioFrameworkExtraBundle\n\n\n\n\nPlease, before using annotations in your project make sure that you know how\nthey work and how to use them. Read the documentation of both packages and try\nto understand their meaning.", 
            "title": "Implement a controller and a command"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-controller-and-a-command/#how-to-implement-a-controller-or-a-command", 
            "text": "Controllers and Commands in Elcodi are exactly the same than Controllers and \nCommands in Symfony. No difference between them. But in Elcodi we have a strong\nphilosophy about how to create them in order to be valid or usable in the Open\nSource environment.  Services in Elcodi  All Elcodi Controllers and Commands are defined as services. This is because we\nare  Overwriting Oriented Programming  and we have in mind that every single\nimplementation sensible to be changed between projects must be easily \ncustomized.  In Symfony, and because Dependency Injection definition has a very well documented\noverwriting strategy, we have decided that everything must be defined as a \nservice.  We have a convention about how a Controller and a Command must be registered in\nyour DI container  elcodi.controller.image_upload\nelcodi.command.populate_currency_rates  Of course, and because it should only depend on the Symfony Components, but never\nthe Symfony Framework nor the FrameworkBundle, both implementations must not extend\nFramework classes.  Framework Controllers in Bamboo  When you work in Bamboo (or in your project on top of Elcodi Components and \nBundles) we don't recommend the usage of Controllers and Commands as services.\nWe think that both implementations are Entry Points and should be Framework\nrelated.  This means that your Controllers or Commands should never have business logic,\nand should place all this logic in your service layer.  Having said that, we recommend the usage of  FrameworkBundle  Controller class to\nendow your controllers with easy access to the DI container and a good set of\npre-built methods.  use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n */\nclass CartController extends Controller\n{\n}  Framework Commands in Bamboo  We have the same opinion for Commands and Controllers.  use Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\n\n/**\n * Cart controllers\n */\nclass MyCommand extends ContainerAwareCommand\n{\n}  Annotations in Bamboo Controllers  In Bamboo, we use annotations in all our controllers in order to make the code more\nunderstandable and to focus only on business logic. Annotations solve\nrepetitive things and should be perfectly documented.   Magic? Yes, of course, same magic than yml readers, than Container\ncompilation, than service builds... so what?   For this reason, we are using  ControllerExtraBundle  and SensioFrameworkExtraBundle .  Let's see an example.  use Mmoreram\\ControllerExtraBundle\\Annotation\\Entity as AnnotationEntity;\nuse Mmoreram\\ControllerExtraBundle\\Annotation\\Form as AnnotationForm;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\n\n/**\n * Cart controllers\n *\n * @Route(\n *      path =  /cart ,\n * )\n */\nclass CartController extends Controller\n{\n    /**\n     * Cart view\n     *\n     * @param FormView      $formView Form view\n     * @param CartInterface $cart     Cart\n     *\n     * @return Response Response\n     *\n     * @Route(\n     *      path =  ,\n     *      name =  store_cart_view ,\n     *      methods = { GET }\n     * )\n     *\n     * @AnnotationEntity(\n     *      class = {\n     *           factory  =  elcodi.wrapper.cart ,\n     *           method  =  loadCart ,\n     *           static  = false,\n     *      },\n     *      name =  cart \n     * )\n     * @AnnotationForm(\n     *      class =  store_cart_form_type_cart ,\n     *      name  =  formView ,\n     *      entity =  cart ,\n     * )\n     */\n    public function viewAction(\n        FormView $formView,\n        CartInterface $cart\n    ) {\n        // ...\n\n        return $this- renderTemplate(\n            'Pages:cart-view.html.twig',\n            [\n                // ...\n            ]\n        );\n    }\n}  You can find some documentation of both annotation packages   ControllerExtraBundle  SensioFrameworkExtraBundle   Please, before using annotations in your project make sure that you know how\nthey work and how to use them. Read the documentation of both packages and try\nto understand their meaning.", 
            "title": "How to Implement a Controller or a Command"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/", 
            "text": "How to Implement a Factory\n\n\nFactories usage is one of the most distinctive things in Elcodi architecture\nstyle. Every single entity in Elcodi ecosystem is created using its own Factory,\nso by default, an entity should never define its own construction state.\n\n\nWe strongly believe that an entity is not responsible of how it should be created,\nso the factory holds this responsibility. This means that an entity should never\nimplement the \n__construct()\n method and it should never initialize any variable.\n\n\nBecause in Elcodi all entity namespaces are defined by a parameter, any factory\nmust use these parameters to create an instance.\n\n\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * @var string\n     *\n     * Entity namespace\n     */\n    protected $entityNamespace;\n\n    /**\n     * Set Entity Namespace\n     *\n     * @param string $entityNamespace Entity namespace\n     *\n     * @return $this Self object\n     */\n    public function setEntityNamespace($entityNamespace)\n    {\n        $this-\nentityNamespace = $entityNamespace;\n\n        return $this;\n    }\n\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this-\ngetEntityNamespace();\n        $language = new $classNamespace();\n\n        $language-\nsetEnabled(false);\n\n        return $language;\n    }\n}\n\n\n\n\nAs you can see, the namespace is injected, and when the factory creates the \ninstance, uses this namespace. With this strategy, the factory becomes uncoupled\nfrom the entity implementation.\n\n\nIn order to make things easier, there is a Trait in package \nelcodi/core\n, \ndesigned to be an abstraction of a Factory. Extending this abstract class, you\ncan access to \n$this-\ngetEntityNamespace()\n.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this-\ngetEntityNamespace();\n        $language = new $classNamespace();\n\n        $language-\nsetEnabled(false);\n\n        return $language;\n    }\n}\n\n\n\n\nFactory as a service\n\n\nBecause the factory dependencies need to be resolved, we must define the factory\nas a service.\n\n\nservices:\n\n    #\n    # Factory for entity language\n    #\n    elcodi.factory.language:\n        class: %elcodi.factory.language.class%\n        calls:\n            - [setEntityNamespace, [\n%elcodi.entity.language.class%\n]]", 
            "title": "Implement a factory"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-factory/#how-to-implement-a-factory", 
            "text": "Factories usage is one of the most distinctive things in Elcodi architecture\nstyle. Every single entity in Elcodi ecosystem is created using its own Factory,\nso by default, an entity should never define its own construction state.  We strongly believe that an entity is not responsible of how it should be created,\nso the factory holds this responsibility. This means that an entity should never\nimplement the  __construct()  method and it should never initialize any variable.  Because in Elcodi all entity namespaces are defined by a parameter, any factory\nmust use these parameters to create an instance.  use Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * @var string\n     *\n     * Entity namespace\n     */\n    protected $entityNamespace;\n\n    /**\n     * Set Entity Namespace\n     *\n     * @param string $entityNamespace Entity namespace\n     *\n     * @return $this Self object\n     */\n    public function setEntityNamespace($entityNamespace)\n    {\n        $this- entityNamespace = $entityNamespace;\n\n        return $this;\n    }\n\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this- getEntityNamespace();\n        $language = new $classNamespace();\n\n        $language- setEnabled(false);\n\n        return $language;\n    }\n}  As you can see, the namespace is injected, and when the factory creates the \ninstance, uses this namespace. With this strategy, the factory becomes uncoupled\nfrom the entity implementation.  In order to make things easier, there is a Trait in package  elcodi/core , \ndesigned to be an abstraction of a Factory. Extending this abstract class, you\ncan access to  $this- getEntityNamespace() .  use Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\nuse Elcodi\\Component\\Language\\Entity\\Interfaces\\LanguageInterface;\n\n/**\n * Class LanguageFactory\n */\nclass LanguageFactory extends AbstractFactory\n{\n    /**\n     * Creates an instance of a simple language.\n     *\n     * This method must return always an empty instance for related entity\n     *\n     * @return LanguageInterface Empty entity\n     */\n    public function create()\n    {\n        /**\n         * @var LanguageInterface $language\n         */\n        $classNamespace = $this- getEntityNamespace();\n        $language = new $classNamespace();\n\n        $language- setEnabled(false);\n\n        return $language;\n    }\n}  Factory as a service  Because the factory dependencies need to be resolved, we must define the factory\nas a service.  services:\n\n    #\n    # Factory for entity language\n    #\n    elcodi.factory.language:\n        class: %elcodi.factory.language.class%\n        calls:\n            - [setEntityNamespace, [ %elcodi.entity.language.class% ]]", 
            "title": "How to Implement a Factory"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/", 
            "text": "How to Implement a Form Type\n\n\nA FormType object in Elcodi ecosystem must follow some rules in order to comply\nwith the project flexibility.\n\n\nUsing Factories\n\n\nRemember that every single entity must be created via its factory in Elcodi\nBundles. For more information, please see \nFactories\n. \nIn order to use this feature in Symfony Form Types, we must inject always the \nrelated entity factory.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\n\n/**\n * @var AbstractFactory\n *\n * Factory\n */\nprotected $factory;\n\n/**\n * Sets Factory\n *\n * @param AbstractFactory $factory Factory\n *\n * @return $this Self object\n */\npublic function setFactory(AbstractFactory $factory)\n{\n    $this-\nfactory = $factory;\n\n    return $this;\n}\n\n\n\n\nAfter the factory is injected, we can use it in our FormType specification for\ndefining the \nempty_data\n value and the \ndata_class\n.\n\n\n/**\n * Default form options\n *\n * @param OptionsResolverInterface $resolver\n *\n * @return array With the options\n */\npublic function setDefaultOptions(OptionsResolverInterface $resolver)\n{\n    $resolver-\nsetDefaults([\n        'empty_data' =\n function () {\n            $this\n                -\nfactory\n                -\ncreate();\n        },\n        'data_class' =\n $this\n            -\nfactory\n            -\ngetEntityNamespace(),\n    ]);\n}\n\n\n\n\nIn order to make things easier, there is a Trait in the package \nelcodi/core\n, \ndesigned as a Factory container. To use it, just add it in your class, like any\nother trait, and you will be able to use the \n$this-\nfactory\n in your class.\n\n\nuse Elcodi\\Component\\Core\\Factory\\Traits\\FactoryTrait;\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * Default form options\n     *\n     * @param OptionsResolverInterface $resolver\n     *\n     * @return array With the options\n     */\n    public function setDefaultOptions(OptionsResolverInterface $resolver)\n    {\n        $resolver-\nsetDefaults([\n            'empty_data' =\n function () {\n                $this\n                    -\nfactory\n                    -\ncreate();\n            },\n            'data_class' =\n $this\n                -\nfactory\n                -\ngetEntityNamespace(),\n        ]);\n    }\n}\n\n\n\n\nUsing namespaces\n\n\nIf your FormType has any kind of relation with another entity, you will need to\ndefine this relation using a namespace. In order to comply again with the\nflexibility, we need to inject all namespaces using the entity manager \nparameter.\n\n\nThese namespaces in Elcodi must be injected through the class constructor.\n\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * @var string\n     *\n     * Image namespace\n     */\n    protected $imageNamespace;\n\n    /**\n     * Construct\n     *\n     * @param string $imageNamespace Image namespace\n     */\n    public function __construct($imageNamespace)\n    {\n        $this-\nimageNamespace = $imageNamespace;\n    }\n\n    /**\n     * buildForm function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            -\nadd('image', 'entity', [\n                'class'    =\n $this-\nimageNamespace,\n                'required' =\n false,\n                'label'    =\n 'image',\n                'multiple' =\n false,\n            ]);\n    }\n}\n\n\n\n\nFormType as a service\n\n\nWe are using dependencies in our FormTypes, so remember that we need to define \nour classes as services.\n\n\nservices:\n\n    #\n    # Form Types\n    #\n    elcodi.admin.banner.form_type.banner:\n        class: Elcodi\\Admin\\BannerBundle\\Form\\Type\\BannerType\n        arguments:\n            - %elcodi.entity.image.class%\n        calls:\n            - [setFactory, [@elcodi.factory.banner]]\n        tags:\n            - { name: form.type, alias: elcodi_admin_banner_form_type_banner }\n\n\n\n\nThe alias of the FormType must be the same as the value returned by the method\n\ngetName()\n of the class\n\n\n/**\n * Return unique name for this form\n *\n * @return string\n */\npublic function getName()\n{\n    return 'elcodi_admin_banner_form_type_banner';\n}", 
            "title": "Implement a form type"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-form-type/#how-to-implement-a-form-type", 
            "text": "A FormType object in Elcodi ecosystem must follow some rules in order to comply\nwith the project flexibility.  Using Factories  Remember that every single entity must be created via its factory in Elcodi\nBundles. For more information, please see  Factories . \nIn order to use this feature in Symfony Form Types, we must inject always the \nrelated entity factory.  use Elcodi\\Component\\Core\\Factory\\Abstracts\\AbstractFactory;\n\n/**\n * @var AbstractFactory\n *\n * Factory\n */\nprotected $factory;\n\n/**\n * Sets Factory\n *\n * @param AbstractFactory $factory Factory\n *\n * @return $this Self object\n */\npublic function setFactory(AbstractFactory $factory)\n{\n    $this- factory = $factory;\n\n    return $this;\n}  After the factory is injected, we can use it in our FormType specification for\ndefining the  empty_data  value and the  data_class .  /**\n * Default form options\n *\n * @param OptionsResolverInterface $resolver\n *\n * @return array With the options\n */\npublic function setDefaultOptions(OptionsResolverInterface $resolver)\n{\n    $resolver- setDefaults([\n        'empty_data' =  function () {\n            $this\n                - factory\n                - create();\n        },\n        'data_class' =  $this\n            - factory\n            - getEntityNamespace(),\n    ]);\n}  In order to make things easier, there is a Trait in the package  elcodi/core , \ndesigned as a Factory container. To use it, just add it in your class, like any\nother trait, and you will be able to use the  $this- factory  in your class.  use Elcodi\\Component\\Core\\Factory\\Traits\\FactoryTrait;\n\n/**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * Default form options\n     *\n     * @param OptionsResolverInterface $resolver\n     *\n     * @return array With the options\n     */\n    public function setDefaultOptions(OptionsResolverInterface $resolver)\n    {\n        $resolver- setDefaults([\n            'empty_data' =  function () {\n                $this\n                    - factory\n                    - create();\n            },\n            'data_class' =  $this\n                - factory\n                - getEntityNamespace(),\n        ]);\n    }\n}  Using namespaces  If your FormType has any kind of relation with another entity, you will need to\ndefine this relation using a namespace. In order to comply again with the\nflexibility, we need to inject all namespaces using the entity manager \nparameter.  These namespaces in Elcodi must be injected through the class constructor.  /**\n * Class BannerType\n */\nclass BannerType extends AbstractType\n{\n    use FactoryTrait;\n\n    /**\n     * @var string\n     *\n     * Image namespace\n     */\n    protected $imageNamespace;\n\n    /**\n     * Construct\n     *\n     * @param string $imageNamespace Image namespace\n     */\n    public function __construct($imageNamespace)\n    {\n        $this- imageNamespace = $imageNamespace;\n    }\n\n    /**\n     * buildForm function\n     *\n     * @param FormBuilderInterface $builder the formBuilder\n     * @param array                $options the options for this form\n     */\n    public function buildForm(FormBuilderInterface $builder, array $options)\n    {\n        $builder\n            - add('image', 'entity', [\n                'class'    =  $this- imageNamespace,\n                'required' =  false,\n                'label'    =  'image',\n                'multiple' =  false,\n            ]);\n    }\n}  FormType as a service  We are using dependencies in our FormTypes, so remember that we need to define \nour classes as services.  services:\n\n    #\n    # Form Types\n    #\n    elcodi.admin.banner.form_type.banner:\n        class: Elcodi\\Admin\\BannerBundle\\Form\\Type\\BannerType\n        arguments:\n            - %elcodi.entity.image.class%\n        calls:\n            - [setFactory, [@elcodi.factory.banner]]\n        tags:\n            - { name: form.type, alias: elcodi_admin_banner_form_type_banner }  The alias of the FormType must be the same as the value returned by the method getName()  of the class  /**\n * Return unique name for this form\n *\n * @return string\n */\npublic function getName()\n{\n    return 'elcodi_admin_banner_form_type_banner';\n}", 
            "title": "How to Implement a Form Type"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/", 
            "text": "How to Implement a Repository\n\n\nCreating a repository in Elcodi is easy. Elcodi type repositories are used in the same\nway Symfony uses its repository classes.\n\n\nEach entity has its own Repository. You will find all entities related \nrepositories inside the Components, hosted in \nRepository/\n folders.\n\n\nAll of them are mostly empty, because they extend \nAbstractRepository\n and, thereby\ndefault, have a set of accessible public methods. However some of them have custom\nmethods in order to build specific and complex queries.\n\n\nIf you want to learn about how to create these methods, please take a look at \nthe \nSymfony Documentation\n\nfor custom repository classes.", 
            "title": "Implement a repository"
        }, 
        {
            "location": "/cookbook/implementation/implement-a-repository/#how-to-implement-a-repository", 
            "text": "Creating a repository in Elcodi is easy. Elcodi type repositories are used in the same\nway Symfony uses its repository classes.  Each entity has its own Repository. You will find all entities related \nrepositories inside the Components, hosted in  Repository/  folders.  All of them are mostly empty, because they extend  AbstractRepository  and, thereby\ndefault, have a set of accessible public methods. However some of them have custom\nmethods in order to build specific and complex queries.  If you want to learn about how to create these methods, please take a look at \nthe  Symfony Documentation \nfor custom repository classes.", 
            "title": "How to Implement a Repository"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/", 
            "text": "How to Implement an Entity\n\n\nIn Elcodi we use an extremely thin model. It means that our entities are just\nparameters, getters and setters.\n\n\nCreating an entity is as easy as defining what an actor should own (parameters),\nforgetting about the behavior of this one. This logic will be placed then in the \nservice layer.\n\n\nLet's see a basic implementation of an entity.\n\n\nclass Product\n{\n    /**\n     * @var name\n     *\n     * Product name\n     */\n    protected $name;\n\n    /**\n     * Get name\n     *\n     * @return string Product name\n     */\n    public function getName()\n    {\n        return $this-\nname;\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Product name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this-\nname = $name;\n\n        return $this;\n    }\n}\n\n\n\n\nAs you can see all properties are defined as protected. This is because Doctrine\nwill need to extend the class using \ntransparent Proxy Objects\n\nto implement lazy-loading.\n\n\nInterfaces\n\n\nAll Elcodi entities are an implementation of a \n\nHeader Interface\n.\nWe use some \n\nRole Interfaces\n in\nour code, but we are more focused in the first one because is more \nunderstandable for everyone when overriding default implementations.\n\n\nuse Elcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface;\n\n/**\n * Class ProductInterface\n */\nclass Product implements ProductInterface\n{\n    // ...\n}\n\n\n\n\nNew entities\n\n\nUsually, final projects need to implement more entities inside their projects.\nSince now, this has been so easy but so magical, and once again, we really think\nthat this stuff should never be magic at all. Is your model, your business.\n\n\nIn our actual implementation, we are using an Open Source project called \n\nSimple Doctrine Mapping\n. \nYou should read carefully the documentation, indeed we strongly recommend it.\n\n\nYes, we need to say that, we'll need to disable the \nauto_mapping\n configuration \nitem inside DoctrineBundle. This flag allow this magic we really want to avoid.\n\n\nInstead of that, we will specifically define how our entities should be defined\nand treated inside our project.", 
            "title": "Implement an entity"
        }, 
        {
            "location": "/cookbook/implementation/implement-an-entity/#how-to-implement-an-entity", 
            "text": "In Elcodi we use an extremely thin model. It means that our entities are just\nparameters, getters and setters.  Creating an entity is as easy as defining what an actor should own (parameters),\nforgetting about the behavior of this one. This logic will be placed then in the \nservice layer.  Let's see a basic implementation of an entity.  class Product\n{\n    /**\n     * @var name\n     *\n     * Product name\n     */\n    protected $name;\n\n    /**\n     * Get name\n     *\n     * @return string Product name\n     */\n    public function getName()\n    {\n        return $this- name;\n    }\n\n    /**\n     * Set name\n     *\n     * @param string $name Product name\n     *\n     * @return $this Self object\n     */\n    public function setName($name)\n    {\n        $this- name = $name;\n\n        return $this;\n    }\n}  As you can see all properties are defined as protected. This is because Doctrine\nwill need to extend the class using  transparent Proxy Objects \nto implement lazy-loading.  Interfaces  All Elcodi entities are an implementation of a  \nHeader Interface .\nWe use some  Role Interfaces  in\nour code, but we are more focused in the first one because is more \nunderstandable for everyone when overriding default implementations.  use Elcodi\\Component\\Product\\Entity\\Interfaces\\ProductInterface;\n\n/**\n * Class ProductInterface\n */\nclass Product implements ProductInterface\n{\n    // ...\n}  New entities  Usually, final projects need to implement more entities inside their projects.\nSince now, this has been so easy but so magical, and once again, we really think\nthat this stuff should never be magic at all. Is your model, your business.  In our actual implementation, we are using an Open Source project called  Simple Doctrine Mapping . \nYou should read carefully the documentation, indeed we strongly recommend it.  Yes, we need to say that, we'll need to disable the  auto_mapping  configuration \nitem inside DoctrineBundle. This flag allow this magic we really want to avoid.  Instead of that, we will specifically define how our entities should be defined\nand treated inside our project.", 
            "title": "How to Implement an Entity"
        }
    ]
}